#
# Flask 知识点
#
1. coding
1.0) usage of decorator
    无参装饰器：两层函数
    带参装饰器：三层函数
    如果用类来实现装饰器，无参：__init__(...) 中传入被装饰的函数，函数 __call(...) 是一层函数；
                          带参：__init_(...) 中传入参数，函数 __call(...) 是两层函数。
    # ref: https://mp.weixin.qq.com/s/KpveR377KifKJ7_drWxFGg

    Example of Usage
    # 带参装饰器 in decorators.py
        from functools import wraps
        from flask import abort
        from flask_login import current_user
        from .models import Permission

        def permission_required(perm):
            def decorator(f):
                @wraps(f)
                def decorated_func(*args, **kwargs):
                    if not current_user.can(perm):
                        return abort(403)
                    return f(*args, **kwargs)
                return decorated_func
            return decorator

        def admin_required(f):
            return permission_required(Permission.ADMIN)(f)

    # in other .py files
        from flask_login import login_required
        from ..decorators import permission_required, admin_required
        from ..models import Permission

        @main.route('/admin')
        @login_required
        @admin_required
        def for_adminis_only():
            return "For administrators!"

        @main.route('/moderate')
        @login_required
        @permission_required(Permission.MODERATE)
        def for_moderators_only():
            return "For comment moderators!"

1.1) usage of context
    A) in test: with self.assertRaises(AttributeError):
                with app.test_request_context('/'):
        see also 3.10.1)B)
        # in test_user_model.py
            import unittest
            from app.models import User

            class UserModelTestCase(unittest.UnitTest):
                def test_user_password_getter(self):
                    u = User(password = 'cat')
                    with self.assertRaises(AttributeError):
                        u.password

    B) in app: @main.app_context_processor, @app.shell_context_processor
        # in app/main/__init__.py:
            from ..models import Permission

            # add Permission into app_context => Permission could be used in template.
            @main.app_context_processor
            def inject_permissions():
                return dict(Permission=Permission)

        I) shell： Flask集成了Python shell
        # in app/nablog.py:
            # to integrate Python shell
            @app.shell_context_processor
            def make_shell_context():
                return dict(db=db, User=User, Role=Role)

    C) in app: with app.app_context()
        with app.app_context():
            mail.send(msg)


2. how to run
    # set on Windows, use export for Linux
        (pweb) D:\workspace\pweb> set FLASK_APP=hello.py
        (pweb) D:\workspace\pweb> flask run
        # open http://127.0.0.1:5000/ in browser.
        # http://127.0.0.1:5000/user/Dave

        # 只接受运行flask的本机的连接
        flask run
        # set FLASK_CONFIG=testing
        flask test
        flask deploy
        flask shell

        # 接受同一网络中的其他计算机发送的连接
        flask run --host 0.0.0.0


    set FLASK_DEBUG=1 doesn't work on Windows for following versions:
        > flask --version
        Python 3.6.4
        Flask 1.1.1
        Werkzeug 0.15.5

3. architecture, diagram, mechanism
3.0) overview
    Flask: microframework, based on werkzeug and jinja2;
           built-in wsgi;
           good routing, blueprint support.

    data flow:
        request comes in <- Request obj: a LocalProxy obj, in rqx_local_stack of LocalStack type,
                                App obj: a LocalProxy obj, in app_local_stack of LocalStack type,
         -> route,       <- @app.route(url, methods=..., ...)
                            or app.url_map_rule(url, endpoint, function).
         -> response

    separate business logic and presentation logic:
        business logic      <- view function
        presentation logic  <- template

3.1) globals (within threads, routines)
    Flask 上下文全局变量：
        current_app: 在应用上下文中使用，     当前应用的应用实例。
        g:           。。。应用上下文。。。， 处理请求时 用作临时存储 的对象，每次请求都会重设这个变量。
        request:     。。。请求上下文。。。， 请求对象，封装了客户端发出的HTTP请求中的内容。
        session:     。。。请求上下文。。。， 用户会话，值为一个字典，存储请求之间需要“记住”的值。

    request attributes and methods:
        form, args, values（form和args的合集）,
        cookies, headers, methods（HEAD, OPTIONS方法由Flask自动处理）,
        files, blueprint, endpoint（处理请求的Flask端点的名称，Flask把视图函数的名称用作路由端口的名字）,
        scheme, host, remote_addr,
        path, query_string, full_path(path和query_string的合集），
            base_url, url（base_url和query_string的合集）,
        environ,
        get_data(), get_json(), is_secure() （是否用HTTPS）。

    request hook:
        @before_request(...),
        @before_first_request(...)： 可用来添加服务器初始化任务。
        @after_request(...)：如果没有未处理的异常抛出，在每次请求之后运行。
        @teardown_request(...)：即使有未处理的异常抛出，也在每次请求之后运行。
    一般在 request hook 和 view function 之间用g来共享数据。
    例如：before_request 中从数据库中加载已登录用户，并保存在g.user中，
            在view function中可以通过g.user获取用户。

    view function and make_response(...) returns a response object.
    response attributes and methods:
        status_code, status, headers, content_length, content_type,
        set_cookie(), delete_cookie(), set_data(), get_data().
    Example:
        @app.route('/')
        def index():
            return '<h1>Bad request</h1>'

            # or
            return '<h1>Bad request</h1>', 400

            # or
            from flask import make_response
            response = make_response('<h1>This document carries a cookie!</h1>')
            response.set_cookie('answer', '42')
            return response

        response.get_data(...) returns by default binary bytes, use as_text=True to convert to string.
            def test_home_page(self):
                response = self.client.get('/')
                self.assertEqual(response.status_code, 200)
                # get_data() returns by default binary bytes.
                self.assertTrue('Stranger' in response.get_data(as_text=True))



    response的快捷方式：redirect(...), abort(...); abort不会把控制权交还给调用它的函数，而是抛出异常。
    Example：
        from flask import redirect

        @app.route('/')
        def index():
            return redirect('http://www.example.com')

        from flask import abort

        @app.route('/user/<id>')
        def get_user(id):
            user = load_user(id)
            if not user:
                abort(404)
            return '<h1>Hello, {}</h1>'.format(user.name)


3.2) configuration
    自定义了一套 Configuration Hierarchy:
        Object -> Config
               -> DevelopmentConfig
               -> TestingConfig
               -> ProductionConfig
                    -> DockerConfig
                    -> UnixConfig
        用 1 dict config 定义 what config uses what class:
            config = {'development': DevelopmentConfig,
              'testing': TestingConfig,
              'production': ProductionConfig,
              'docker': DockerConfig,
              'unix': UnixConfig,
              'default': DevelopmentConfig
            }
        每个 Config 类定义属性，方法，如
        class Config(object):
            @staticmethod
            def init_app(app):
                pass

        class ProductionConfig(Config):
            @classmethod
            def init_app(cls, app):
                Config.init_app(app)
                ...
    使用：
        如  app.config.from_object(config[config_name])
            config[config_name].init_app(app)

            current_app.config['...']

3.3) routing
    静态路由：'/user'：静态路由的例子；
             'static/<filename>'：Flask自动生成，例如 url_for('static', filename='css/styles.css', _external=True)，
                                  将得到http://localhost:5000/static/css/styles.css。
    dynamic routing:
                     '/user/<name>'：动态路由；
                     url_for('index'): 得到 / ;
                     url_for('index', _external=True)：得到 http://localhost:5000/ ;
                     url_for('user', name='john', _external=True)：得到 http://localhost:5000/user/john 。

3.4) template
    template:        a file including static part and dynamic part (placeholder).
    template engine: jinja2.
    render:          the process to replace placeholder using value, return response.

    jinja2 可以识别出所有类型的变量，包括列表、字典和对象。
        <p>A value from a dictionary: {{ mydict['key'] }}.</p>
        <p>A value from a list: {{ mylist[3] }}.</p>
        <p>A value from a list, with a variable index: {{ mylist[myintvar] }}.</p>
        <p>A value from an object's method: {{ myobj.somemethod() }}.</p>

    jinja2 过滤器：
        Hello, {{ name|capitalize }}

        safe（渲染值时不转义。默认Jinja2会转义，为了安全考虑，例如<h1>转义为&lt;h1&gt;）,
        capitalize, lower, upper, title（每个单词首字母大写）, trim, striptags（把HTML标签删掉）.

        ！！不要在不可信的值上用safe，例如用户在表单中输入的文本！！

    template 支持if, for, macro定义和使用，import, 继承via block, extends, super()。

3.5) blueprint
    routing:  @app.route('/', methods=[...]) # or @main.route('/', methods=[...])
                +
              view functions;
              <=> 必须在创建 app 之后创建。

    blueprint: 和应用一样，可以定义路由和错误处理程序；
                blueprint 可以按功能划分，相对独立：不同的功能可以写入不同的模块；
                blueprint 定义后休眠状态，直到注册到应用之后，才真正称为应用的一部分。
        e.g.
            # in app/main/__init__.py:
                from flask import Blueprint

                main = Blueprint('main', __name__)
                from . import views, errors

            # in app/__init__.py:
                from .main import main as main_blueprint
                app.register_blueprint(main_blueprint)
                ...
                app.register_blueprint(auth_blueprint, url_prefix='/auth')

3.6) authentication, admin
    G) Flask-Login：管理已登陆用户的session;
    M) Flask-HttpAuth 提供了 HTTP 身份验证协议的封装，把协议的细节隐藏在装饰器之中。
    O) Flask-Admin 提供一个 admin 平台，适合于小型快速开发，例如博客、小型论坛、小型官网等等。

3.7) database connection
    D) Flask-SQLAlchemy: SQLAlchemy 是一个强大的关系型数据库框架，支持多种数据库后台。
                     Object Relationship Mapping (ORM) 包。
                     SQLAlchemy 提供了高层ORM的功能，也提供了原生SQL的底层功能。
    E) Flask-Migrate：数据库迁移。数据库迁移工具能跟踪数据库模式的变换，然后以增量的方式把变化应用到数据库中。

3.8) flash(...), get_flashed_messages()
    # in view functions
    from flask import flash
        flash('...')

    # in template e.g. app/templates/base.html:
        {% block content %}
        <div class="container">
            {% for message in get_flashed_messages() %}
            <div class="alert alert-warning">
                <button type="button" class="close" data-dismiss="alert">&times;</button>
                {{ message }}
            </div>
            {% endfor %}

            {% block page_content %}{% endblock %}
        </div>
        {% endblock %}

3.9) security
    F) Werkzeug：计算密码的散列值并进行核对
    H) itsdangerous：生成并核对 加密安全令牌

3.10) test
3.10.1) Example 1. use built-in unittest to do test.
    A) code-snippet
        import unittest
        tests = unittest.TestLoader().discover('tests') # tests/ is the directory under which test_basics.py locates.
        # or
            # it works with flask test tests.test_api
            tests = unittest.TestLoader().loadTestsFromNames(test_names)

        unittest.TextTestRunner(verbosity=2).run(tests)

        # @unittest.skip(reason='[1 extra space in index.html: Hello, john !] self.client.page_source is None after login')
        def test_admin_home_page(self):
            ...

    B) use with app.test_request_context('/') to activate a temporary request context激活一个临时的请求上下文
        with self.app.test_request_context('/'): fixes following errors:
        (1) RuntimeError: Working outside of request context.
        (2) RuntimeError: Application was not able to create a URL adapter for request independent URL generation.

            def test_gravatar(self):
                user = User(email='john@example.com', password='cat')
                # with is to fix RuntimeError: Working outside of request context.
                #   gravatar(...) needs an active HTTP request: it calls request.....
                with self.app.test_request_context('/'):
                    gravatar = user.gravatar()
                    gravatar_256 = user.gravatar(size=256)
                    gravatar_pg = user.gravatar(rating='pg')
                    gravatar_retro = user.gravatar(default='retro')
                self.assertTrue('https://secure.gravatar.com/avatar/d4c74594d841139328695756648b6bd6' in gravatar \
                                or 'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6' in gravatar)
                self.assertTrue('s=256' in gravatar_256)
                self.assertTrue('r=pg' in gravatar_pg)
                self.assertTrue('d=retro' in gravatar_retro)

            def test_no_auth(self):
                # url_for('api.get_posts') didn't work here
                #   RuntimeError: Application was not able to create a URL adapter for request independent URL generation.
                #   You might be able to fix this by setting the SERVER_NAME config variable.
                # <=> with self.app.test_request_context('/'): fixed it.
                with self.app.test_request_context('/'):
                    response = self.client.get(url_for('api.get_posts'), content_type='application/json')
                # .get('/api/v1/posts/'...) works too.
                # response = self.client.get('/api/v1/posts/', content_type='application/json')
                self.assertEqual(response.status_code, 401)


    C) use with.self.assertRaises(...):
           def test_user_password_getter(self):
                u = User(password = 'cat')
                with self.assertRaises(AttributeError):
                    u.password

    D) use self.app.test_client() as a testing web client:
           .test_client(...) is a Flask built-in test client
                用来解决（至少部分解决）代码严重依赖运行中的应用所创建的环境，即视图函数只能在请求上下文和运行中的应用里运行。
                    如不能直接调用视图函数中的代码进行测试，因为函数需要访问Flask上下文变量如 request 或 session；
                    视图函数可能还等待接收 POST 请求中的表单数据，而视图函数可能要求用户先登录。

            self.client = self.app.test_client(use_cookies=True)    # for web application: use use_cookies=True
            self.client = self.app.test_client()                    # for API don't use use_cookies=True

    E) HTTP status code
        302 - redirect
        400 - bad request
        401 - unauthorized
        403 - forbidden
        404 - not found

        when HTTP request failed, response has .status_code, .status, could have no data:
            response.get_data(as_text=True) has <title><script> etc.,
            but json.loads(response.get_data(as_text=True)) errors out.

            def test_404(self):
                response = self.client.get('/wrong/url', headers=self.get_api_headers('nouser', 'nopasswd'))
                self.assertEqual(response.status_code, 404)
                # for /wrong/url, response.get_data(as_text=True) has <title><script> etc., but
                #   json.loads(response.get_data(as_text=True)) errors out:
                #       raise JSONDecodeError("Expecting value", s, err.value) from None
                #       json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
                # => use response.status instead, which is '404 NOT FOUND'.
                self.assertEqual(response.status, '404 NOT FOUND')


        # ref: http://docs.jinkan.org/docs/flask/testing.html
        # ref: https://stackoverflow.com/questions/45821222/fire-multiple-requests-in-a-flask-test-request-context

    F) FAQ:
        C.1) in sub-class of unittest.TestCase:
            either remove __init__ or in exact __init__(self, *args, **kwargs) format, otherwise:
              TypeError: __init__() takes 1 positional argument but 2 were given

            <= "TestCase instances take an optional keyword argument methodName;
                I'm guessing the unittest module passes this explicitly behind the scenes at some point."

        class BasicsTestCase(unittest.TestCase):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)
                print('[TO BE REMOVED] in __init__ function in BasicsTestCase class.')

    ref: https://stackoverflow.com/questions/47445137/unittest-selenium-init-takes-1-positional-argument-but-2-were-given
    ref: https://stackoverflow.com/questions/42790980/python-unittest-throws-uncaught-typeerror-init-takes-1-positional-argumen/42791106


3.10.2) Example 2. use coverage lib to check test coverage

        pip install coverage

        Usage Example 1.
            if os.environ.get('FLASK_COVERAGE'):
                import coverage
                COV = coverage.coverage(branch=True, include='app/*')
                COV.start()

            # set FLASK_COVERAGE env.-variable and restart self
            if coverage and not os.environ.get('FLASK_COVERAGE'):
                os.environ['FLASK_COVERAGE'] = '1'
                # to fix error:
                #   d:\workspace\pweb\scripts\python.exe: can't open file 'd:\workspace\pweb\scripts\flask':
                #                                         [Errno 2] No such file or directory
                #
                sys.argv[0] += '.exe'
                # print('[TO debug] sys.executable={}\nsys.argv={}'.format(sys.executable, sys.argv))
                os.execvp(sys.executable, [sys.executable] + sys.argv)

            # run the tests
            import unittest
            # ...

            # check coverage
            if COV:
                COV.stop()
                COV.save()
                print('Coverage Summary:')
                COV.report()
                covdir = os.path.join(os.path.absdir(os.path.dirname(__file__)), 'tmp/coverage')
                COV.html_report(directory=covdir)
                print('HTML version: file://{}/index.html'.format(covdir))
                COV.erase()

        os.execvp(...)用法：
            sys.argv[0] += '.exe'
            os.execvp(sys.executable, [sys.executable] + sys.argv)
            os.execvp('mkdir', ['mkdir', '/tmp/test1/'])
        os.system(command) 与 os.exec*(...)系列的区别：
            os.system(command) 是在一个程序内部启动另一个程序，从而创建一个新进程
            os.system(command) 是在 shell 中执行 command 命令，是C中 system() 的 Python 实现，
                                具有相同的限制条件：
                                在Unix系统中，返回值是命令执行后的退出状态，
                                由于POSIX没有为C中 system() 的返回值指定明确的定义，
                                所以os.system(command)的返回值依赖具体的系统，
                                在Windows中，返回值由系统环境变量 COMSPEC 决定，此环境变量依据不同的系统版本而不同。
            <=> 官方建议用 subprocess 模块的功能来代替此函数。

        os.exec* 系列都执行一个新程序，然后用新的程序替换当前子进程的进程空间。
                 而该子进程从新程序的main函数开始执行。
        os.execl(path, arg0, arg1, ...)
        os.execlp(file, arg0, arg1, ...)
        os.execle(path, arg0, arg1, ..., env)
        os.execlpe(file, arg0, arg1, ..., env)
        os.execv(path, args)
        os.execvp(file, args)
        os.execve(path, args, env)
        os.execvpe(file, args, env)
            os.execl*: 参数是一个一个独立的参数传入；
            os.execv*: 参数是 list 或者 tuple 形式；
            os.exec*p: 从 PATH 环境变量中查找运行的executable；参数args中 args[0]是executable，args[1:]参数。
            os.exec*e: 用给定的 env 作为默认的环境配置。env参数必须是一个 mapping， 可以是一个 dict 类型的对象。

        # ref: https://www.cnblogs.com/nisen/p/6060355.html
        # ref: https://blog.csdn.net/KWSY2008/article/details/52349836

3.10.3) Example 3. use selenium as web browser
    A) Selenium 是一个Web浏览器自动化工具，
             可以模拟浏览器来执行在客户端浏览器中运行的JavaScript代码等；
             可以进行自动化操作。
             Selenium 测试是直接在浏览器中进行，要求被测试的应用运行在后台线程里的开发服务器中，Selenium运行在主线程中：
              selenium.webdriver -> create a browser instance
                                 -> use the browser to do testing, communicate with the application
                                 -> close the browser instance , shutdown webdriver
               <= 需要优雅的停止开发服务器，如Flask built-in Web Server：
                        因为开发服务器运行在线程中，只能发送一个普通的HTTP请求停止它。

    B) pip install selenium
            download chromedriver.exe for win10 and put it to C:\chromedriver_win32\, add its_installation_path to PATH.

        from selenium import webdriver
        ...
        # in setUpClass(cls):
            try:
                cls.client = webdriver.Chrome(chrome_options=options)
                ...
            # do testing only when a browser is started
            if cls.client:
                ...
                 # start Flask web server in a thread
                cls.server_thread = threading.Thread(target=cls.app.run, kwargs={'debug': False})
                cls.server_thread.start()
                ...
        # in test_admin_home_page(self):
            ...
            self.client.find_element_by_link_txt(...).click()
            self.client.find_element_by_name(...).click()
            self.client.find_element_by_name(...).send_keys(...)
            ...
            self.assertIn(..., self.client.page_source)
            ...

    C) FAQ
    (1) when not running nablog.py via flask ..."__main__":app.run(),
        run flask test tests.test_selenium in CLI, got an exception:
                C:\Python36\lib\threading.py:864: Warning: Silently ignoring app.run() because
                the application is run from the flask command line executable.
                Consider putting app.run() behind an if __name__ == "__main__" guard to silence this warning.
        root-cause:
            "This is a bug in Flask, introduced in the 1.0 release. I have filed an issue a while ago: pallets/flask#2776.
            If you downgrade Flask to 0.12.2 this should work as expected."

        # ref: https://github.com/miguelgrinberg/flasky/issues/372


3.11) distribution, deployment
    A) archive code into git repository
        git add ...
        git commit -m '...'
        git tag -a 10a cf73927 -m '...'
        git push --follow-tags

    B) use flask deploy in CLI:
        from flask_migrate import upgrade

        @app.cli.command()
        def deploy():
            ...

    C) logging
        应用启动时，Flask会创建一个 Python 的 logging.Logger 类实例，并将其attach to app instance, 通过 app.logger 访问。
        默认情况下，Debug模式下，日志记录器把日志写入控制台；生产模式中，默认情况下没有配置一个日志处理程序。
        <=> 需要手动添加日志处理程序，如果不添加就不会保存日志。

    D) use docker to deploy application
    # on win10, in cmd CLI:
        # download Docker Desktop, install.
        # Docker Desktop

    # on win10, in git bash CLI:
        docker version  # if it errored out, see docker FAQ part below.
        docker info

        基容器映像 是基于 Alpine Linux发行版构造的 Python映像。Alpine Linux常用于容器映像，因为它体量小。
        macOS 和 Windows 版 Docker 能运行基于 Linux 的容器。

        # create Dockfile（exec file 文件大小写敏感）, boot.sh（文件大小写敏感）, class DockerConfig,
        # cd Dockfile_directory
        docker build -t nablog:latest .

        docker images
        docker image rm 8d59bfc95e9b
        docker rmi  # delete an image

        docker run --name nablog -d -p 8000:5000 \
            -e SECRET_KEY=... \
            -e MAIL_USERNAME=...\
            -e MAIL_PASSWORD=... nablog:latest

        docker ps
        docker ps -a                # check exited containers too
        docker logs 2bbe400e2ab5    # check logs, exiting reason
        # ref: https://stackoverflow.com/questions/55260610/docker-ps-shows-empty-list-although-docker-telling-container-exists


        docker stop container_id
        docker rm container_id
        # both above can integrate into docker rm -f container_id

        # to debug
        docker exec -it container_id sh

        # in browser, open http://localhost:8000/, it works.

        # difference between docker and docker-machine commands:
            docker commands:            used only within a VM to manage images.
            docker-machine commands:    used on the host to manage Linux VMs.

            # ref: https://stackoverflow.com/questions/40459280/docker-cannot-start-on-windows/55459504

    # docker FAQ
        用 Docker 部署 win10 的时候出错:
        (1) in Windows cmd CLI
        > docker version
        Client: Docker Engine - Community
         Version:           19.03.1
         API version:       1.40
         Go version:        go1.12.5
         Git commit:        74b1e89
         Built:             Thu Jul 25 21:17:08 2019
         OS/Arch:           windows/amd64
         Experimental:      false
        error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.40/version: open //./pipe/docker_engine:
        The system cannot find the file specified. In the default daemon configuration on Windows,
        the docker client must be run elevated to connect.
        This error may also indicate that the docker daemon is not running.

        Root-cause：
            docker doesn't work perfectly on Windows, Windows has own docker implementation
                using VirtualBox (use --driver, -d "virtualbox").

        Fix / Workaround:
            docker-machine ls
            # empty, no machine, create 1 with docker-machine create

            docker-machine create default1
            # errored out
            >docker-machine create default1
                Creating CA: C:\Users\naliliu\.docker\machine\certs\ca.pem
                Creating client certificate: C:\Users\naliliu\.docker\machine\certs\cert.pem
                Running pre-create checks...
                Error with pre-create check: "This computer is running Hyper-V.
                VirtualBox won't boot a 64bits VM when Hyper-V is activated.
                Either use Hyper-V as a driver, or disable the Hyper-V hypervisor.
                (To skip this check, use --virtualbox-no-vtx-check)"

            docker-machine create default1 --virtualbox-no-vtx-check
            # errored out
                >docker-machine create default1 --virtualbox-no-vtx-check
                    Running pre-create checks...
                    (default1) Image cache directory does not exist, creating it
                        at C:\Users\naliliu\.docker\machine\cache...
                    (default1) No default Boot2Docker ISO found locally, downloading the latest release...
                    (default1) Latest release for github.com/boot2docker/boot2docker is v19.03.1
                    (default1) Downloading C:\Users\naliliu\.docker\machine\cache\boot2docker.iso from
                    https://github.com/boot2docker/boot2docker/releases/download/v19.03.1/boot2docker.iso...
                    (default1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%
                    Creating machine...
                    (default1) Copying C:\Users\naliliu\.docker\machine\cache\boot2docker.iso to
                    C:\Users\naliliu\.docker\machine\machines\default1\boot2docker.iso...
                    (default1) Creating VirtualBox VM...
                    (default1) Creating SSH key...
                    (default1) Starting the VM...
                    (default1) Check network to re-create if needed...
                    (default1) Windows might ask for the permission to create a network adapter.
                        Sometimes, such confirmation window is minimized in the taskbar.
                    (default1) Found a new host-only adapter: "VirtualBox Host-Only Ethernet Adapter #2"
                    (default1) Windows might ask for the permission to configure a network adapter.
                        Sometimes, such confirmation window is minimized in the taskbar.
                    (default1) Windows might ask for the permission to configure a dhcp server.
                    Sometimes, such confirmation window is minimized in the taskbar.
                    Error creating machine: Error in driver during machine creation:
                        Unable to start the VM:
                        C:\Program Files\Oracle\VirtualBox\VBoxManage.exe startvm default1 --type headless failed:
                    VBoxManage.exe: error:  (VERR_NEM_MISSING_KERNEL_API).
                    VBoxManage.exe: error: VT-x is not available (VERR_VMX_NO_VMX)
                    VBoxManage.exe: error: Details: code E_FAIL (0x80004005), component ConsoleWrap, interface IConsole

                    Details: 00:00:03.245217 Power up failed (vrc=VERR_VMX_NO_VMX, rc=E_FAIL (0X80004005))
            # but Desktop Docker in GUI works, docker version in CLI works, docker run hello-world in CLI works.
            #		"C:\Program Files\Oracle\VirtualBox\VBoxManage.exe" startvm default3 not working.

                > docker version
                    Client: Docker Engine - Community
                     Version:           19.03.1
                     API version:       1.40
                     Go version:        go1.12.5
                     Git commit:        74b1e89
                     Built:             Thu Jul 25 21:17:08 2019
                     OS/Arch:           windows/amd64
                     Experimental:      false

                    Server: Docker Engine - Community
                     Engine:
                      Version:          19.03.1
                      API version:      1.40 (minimum version 1.12)
                      Go version:       go1.12.5
                      Git commit:       74b1e89
                      Built:            Thu Jul 25 21:17:52 2019
                      OS/Arch:          linux/amd64
                      Experimental:     false
                     containerd:
                      Version:          v1.2.6
                      GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
                     runc:
                      Version:          1.0.0-rc8
                      GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
                     docker-init:
                      Version:          0.18.0
                      GitCommit:        fec3683

                >docker-machine ls
                    NAME       ACTIVE   DRIVER       STATE     URL   SWARM   DOCKER    ERRORS
                    default1   -        virtualbox   Stopped                 Unknown

        # ref: https://github.com/docker/for-win/issues/1825

        windows features:
            Hyper-V: turn on
            Virtual Machine Platform: turn on (not working)
            # ref: https://superuser.com/questions/1391838/virtual-box-is-not-working-on-windows-10

            （not working) After updating Windows 10 to "Fall Creators Update" I got the same issue.
                I resolved it by the following steps:
                Enable all features under "Hyper-V" in "Turn Windows features on or off".
                Restart.
                Disable all features under "Hyper-V" in "Turn Windows features on or off".
                Restart.
                Now VirtualBox is working again and it shows (64-bit) in its list of operating systems.
            # ref: https://superuser.com/questions/1153470/vt-x-is-not-available-but-is-enabled-in-bios

    # push docker images to docker-hub
        [TODO to confirm] # register in https://hub.docker.com
        # in CLI:
        docker login

        # 如果想登录 Docker Hub 之外的容器映像仓库，把仓库的地址作为参数传给 docker login 命令。
        docker login <other_container_hub_repository>

        docker push <your-dockerhub-username>/nablog:latest
        docker run --name nablog -d -p 8000:5000 <your-dockerhub-username>/nablog:latest

    # 使用外部数据库
    使用Docker 容器部署有个缺点：应用默认使用SQLite数据库在容器内很难升级，因为容器一旦停止运行、数据库就不见了。

    => 在应用的容器之外托管数据库服务器，这样升级应用的时候只需换个新容器，数据库可以保留下来。
        例如，用一个容器构建数据库：
            docker run --name mysql -d \
                -e MYSQL_RANDOM_ROOT_PASSWORD=yes \
                -e MYSQL_DATABASE=nablog \
                -e MYSQL_USER=nablog -e MYSQL_PASSWORD=<database-password> mysql/mysql-server:5.7
        <= 需要安装MySQL客户端包如 pymysql，和 MySQL数据库连接。

        然后启动一个新容器运行应用：
            docker run -d -p 8000:5000 --link mysql:dbserver \
                -e DATABSE_URL=mysql+pymysql://nablog:<database-password>@dbserver/nablog \
                -e MAIL_USERNAME=... -e MAIL_PASSWORD=... \
                nablog:latest

        --link <target_container_name_or_id>:<alias_of_container_in_current_container>,
            是为了把正在启动run的容器和一个现有的容器连接起来。

        MySQL容器映像把所有的数据库文件都放在一个卷中。
            docker volume ls    # 查看
            docker volume rm    # 删除
            docker system prune --volumes   # 删除所有不再使用的映像或卷，和停止后依然在系统中的容器

    E) use docker compose to compose containers
        docker-compose version

        Docker Compose acts similarly to Kubernetes, Apache Mesos, Docker-Swarm（并入Docker）。
            提供编排功能。
            例如应用需要多个容器：数据库、应用本身、消息队列或者缓存；
                或者应用采用微服务架构，以分布式结构部署多个小型子应用，分布运行在单独的容器中；
                或者是提供高负载或者高容错的应用需要进行伸缩，在负载均衡背后运行多个实例，等等。

        Docker Compose:
            All containers are described in a configuration file e.g. docker-compose.yml,
            docker-compose 一次性启动全部容器。

            docker-compose up -d --build

            docker-compose logs
            docker-compose logs -f

            docker-compose ps
            docker-compose down
            docker-compose rm --stop --force

            docker-compose.yml： YAML格式的配置文件，以键值对、列表定义层次结构。

    F) 在生成环境中使用Docker的利弊
        利：简单、升级快、部署快、通过编排保障可靠性和伸缩性。
        弊：不易监控和提醒（如容器不稳定时不会发出警告）；
            日志没有长期存储机制、没有搜索和过滤功能；
            机密信息管理不够（如事先配置好的环境变量可以通过 docker inspect 命令或API访问）。

    G) on premise deployment 内部部署，传统的部署在物理或虚拟服务器上，非云端。
        可以用自动化框架如 Ansible、Chef 或 Puppet 编写一个部署脚本：
            （1）安装数据库服务器，例如 MySQL 或 Postgres；
            （2）安装邮件传输代理 Mail Transport Agent (MTA)，例如 Sendmail 或 Postfix；
            （3）安装适用于生产环境的Web服务器，如 Gunicorn 或 uWSGI；
            （4）安装一个进程监控工具，例如 Supervisor；
            （5）启用 HTTPS，安装配置 SSL 证书；
            （6）（可选，强烈推荐）安装前端反向代理服务器，如 nginx 或 Apache；
            （7）提升服务器的安全性，如 安装防火墙、删除不用的软件和服务。

3.12) extension
    A) Flask-Bootstrap: Bootstrap是twitter开源的一个用于开发web的客户端框架，提供用户界面组件，兼容桌面和移动浏览器。
                        服务器只是提供引用了CSS、Javascript的response，
                              并在HTML、CSS、Javascript代码中实例化所需的用户界面元素。

        pip install flask-bootstrap
        其 boostrap/base.html中，定义了如下block：
            doc, html, html_attribs, head, title, metas（一组meta标签）,
            styles（CSS声明）, body, body_attribs, navbar, content, scripts（文档底部的JavaScript声明）.

         Usage example:
            # in hello.py
            from flask-bootstrap import Bootstrap
            bootstrap = Bootstrap(app)

            # copy templates of bootstrap to templates/bootstrap/
            # in templates/base.html
            {% extends bootstrap/base.html %}

        Bootstrap 中 data-toggle 和 data-target 的作用：
            定义 data-target 指定的元素以 data-toggle 指定的形式显示。
            HTML5 运行用户自定义标签，自定义标签大多以 data- 开头。
                Bootstrap 中，data-toggle指事件以什么触发，如 modal, toggle, dropdown, popover, tooltip etc.
                              data-target指事件的目标，如 id属性或者 class属性。

        # ref: data-toggle与data-target是什么作用 https://blog.csdn.net/d295968572/article/details/56667863
        # ref: 关于bootstrap的data-toggle和data-target https://blog.csdn.net/weixin_37986839/article/details/76593332

    B) Flask-Moment：Moment.js 是一个优秀的 JavaScript 开发的在客户端浏览器中渲染日期和时间的开源库，
                     Flask-Moment 是一个Flask扩展，能简化把 Moment.js 集成到 Jinja2模板中的过程。
                     Flask-Moment 依赖于 Moment.js, jQuery.js。jQuery.js 在 Bootstrap 中已引入。
                     Flask-Moment 实现了 Moment.js 中的 format(), fromNow(), fromTime(), calendar(), valueOf()
                                  和 unix() 等方法。
                     Flask-Moment 假定服务器端应用处理的时间戳是“纯正的”datetime对象，且使用UTC表示。

        pip install flask-moment
        Usage example:
            # in hello.py
            from datetime import datetime
            from flask-moment import Moment
            moment = Moment(app)

            @app.route('/')
            def index():
                return render_template('index.html', current_time=datetime.utcnow())

            # in templates/base.html
            {% block scripts %}
            {{ super() }}
            {{ moment.include_moment() }}
            {{ moment.locale('zh-cn') }}       # add locale language support, zh-cn: Chinese, es: Spanish
            {% endblock %}

            # in templates/index.html
            <p>The local date and time is {{ moment(current_time).format('LLL') }}.</p>
            <p>That was {{ moment(current_time).fromNow(refresh=True) }}.</p>


    C) Flask-WTF：创建Web表单等，这个扩展对独立的 WTForms 包进行了包装，方便集成到Flask应用中。
                    WTForms 包本身可与多个框架集成。

            pip install flask-wtf

            app.config['SECRET_KEY'] is needed to protect against CrossSiteRequestForgery (CSRF) attack,
                and Flask generates token for each form and stores into session.

            测试中，需要绕过 CSRF 使 POST form data 的测试容易些：WTF_CSRF_ENABLED = False
            # in config.py:
                class TestingConfig(Config):
                TESTING = True
                # to easily test forms submission in HTTP POST request: to disable CSRF token
                WTF_CSRF_ENABLED = False
                SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or 'sqlite://'

            配置 SECRET_KEY 可以用 app.config['SECRET_KEY']，最好是放在环境变量里。
            # export SECRET_KEY=...
            set SECRET_KEY=...

        WTForms 支持的HTML标准字段：
            BooleanField, HiddenField, PasswordField, DateField, DateTimeField,
            FileField, MultipleFileField, DecimalField, IntegerField, FloatField,
            StringField, TextAreaField, RadioField, SelectField, SelectMultipleField,
            FieldList, FormField, SubmitField.

        WTForms 内建的验证函数：
            InputRequired （确保转换类型前字段中有数据）， DataRequired （确保转换类型后字段中有数据），
            URL, UUID, Email, IPAddress, MacAddress, EqualTo, Length, NumberRange, Regexp,
            Optional （允许字段中没有输入，将跳过其他验证函数）, AnyOf, NoneOf.

        手动处理、渲染 forms 需要重复coding，用 bootstrap 的wtf.quickform(form)。

        Usage example:
            # in hello.py
            from flask import Flask, render_template, redirect, url_for
            from flask_wtf import FlaskForm
            from wtforms import StringField, SubmitField
            from wtforms.validators import DataRequired

            app.config['SECRET_KEY'] = '...'

            class NameForm(FlaskForm):
                name = StringField('What is your name?', validators=[DataRequired()])
                submit = SubmitField('Submit')

            @app.route('/', methods=['GET', 'POST'])
            def index():
                name, form = None, NameForm()
                if form.validate_on_submit():
                    name = form.name.data
                    form.name.data = ''
                    return redirect(url_for('.index'))
                else:
                    return render_template('index.html', current_time=datetime.utcnow(), form=form, name=name)

            # in templates/index.html
            {% import "bootstrap/wtf.html" as wtf %}

            {{ wtf.quick_form(form) }}
            <p></p>

    D) Flask-SQLAlchemy: SQLAlchemy 是一个强大的关系型数据库框架，支持多种数据库后台。
                         Object Relationship Mapping (ORM) 包。
                         SQLAlchemy 提供了高层ORM的功能，也提供了原生SQL的底层功能。

    D.1) Flask-SQLAlchemy 配置
        pip install flask-sqlalchemy

        Flask-SQLAlchemy 简化了 SQLAlchemy 在 Flask 中的应用。
        在 Flask-SQLAlchemy 中，数据库使用URL指定，如：
            MySQL:                  mysql://username:password@hostname/database
            Postgres:               postgresql://username:password@hostname/database
            SQLite (Linux, MacOS):  sqlite:///absolute/path/to/database
            SQLite (Windows):       sqlite:///c:/absolute/path/to/database
        此 URL 必须保存到 Flask 配置对象的 SQLALCHEMY_DATABASE_URI 键中。
        而且， SQLALCHEMY_TRACK_MODIFICATIONS = False

    D.2) Flask-SQLAlchemy 内置对象、方法和选项
        常用的SQLAlchemy列类型：
            Integer, SmallInteger, BigInteger, Float, Numeric,
            String, Text, Unicode, UnicodeText, (db.String 需要指定长度，db.Text是变长字段，不需要指定最大长度），
            Boolean, Date, Time, DateTime, Interval （对应Python中的datetime.timedelta），
            Enum （对应Python中的str，一组字符串）,
            PickleType （对应Python中的任何Python对象，自动使用Pickle序列化）,
            LargeBinary （对应Python中的str，二进制blob）。
        常用的SQLAlchemy列选项：
            primary_key, unique, index, nullable, default.
        常用的SQLAlchemy关系选项，用在函数 db.relationship(...) 中：
            backref, primaryjoin, lazy, uselist（一对一时可设为False）, order_by, secondary, secondaryjoin.
            backref: 默认是 select(关系两端任何一方首次访问的时候按需加载),
                            joined（加载记录，但使用联结，一次加载所有的记录），
                            immediate（源对象加载后就加载），
                            subquery（立即加载，但使用子查询），
                            noload（永不加载），
                            dynamic（不加载记录，但提供加载记录的查询）。


    D.3) Flask-SQLAlchemy 中数据库的关系如何定义
        一对一：在一的一方用 db.relationship(..., uselist=False...)设置，
                另一方用? (TODO)

        一对多：在一的一方用 db.relationship(...)设置，
                在多的一方用 db.ForeignKey(...)
                Example 1vsN:
                    class Role(db.Model):
                        users = db.relationship('User', backref='role', lazy='dynamic')
                        ...
                    class User(db.Model):
                        role_id = db.Column(db.Integer, db.ForeignKey('Role.id')
                        ...

        自引用关系：如果关系中的两侧都在同一个表中，这种关系称为自引用关系。
                    自引用关系可以是一对一、一对多、多对多。

            # ref: http://etutorials.org/SQL/Database+design+for+mere+mortals/Part+II+The+Design+Process/Chapter+10.+Table+Relationships/Types+of+Relationships/

        多对多：方法1. 添加第三张表，这个表称为关联表。
                        通过 db.Table(...) 创建关联表；
                        在关联表两端的其中一个模型类中，
                            通过 db.relationship(...， secondary=<connection_table>, ...) 定义关系。
                       关系表是 SQLAlchemy 掌控的内部表，无法添加字段，如用户关注另一个用户的时间戳。

                Example NvsN via connection_table: students <-> registrations <-> classes

                    registration = db.Table('registration',
                        db.Column('student_id', db.Integer, db.ForeignKey('students.id')),
                        db.Column('class_id', db.Integer, db.ForeignKey('classes.id'))
                    )

                    class Student(db.Model):
                        __tablename__ = 'students'
                        id = db.Column(db.Integer, primary_key=True)
                        name = db.Column(db.String)
                        classes = db.relationship('SchoolClass',
                                                  secondary=registration,
                                                  backref=db.backref('students', lazy='dynamic'),
                                                  lazy='dynamic')

                    class SchoolClass(db.Model):
                        __tablename__ = 'classes'
                        id = db.Column(db.Integer, primary_key=True)
                        name = db.Column(db.String)

                    # in flask shell:
                    >>> c = SchoolClass(name='c1')
                    >>> s = Student('s1')

                    >>> s.classes.append(c)
                    >>> s.classes.remove(c)
                    >>> db.session.add(s)
                    >>> db.session.rollback()

                    >>> s.classes.all()
                    >>> c.students.all()


                方法2. 提升关联表为一个模型，即自定义模型来起到关联表的作用。
                        为关联表定义一个 Model，加上自定义字段；
                        在多对多关系的两端各自定义一个一对多关系 db.relationship(...)，
                            如果同时是自引用关系，用选项 foreign_keys=[...] 指定外键，为了消除两端两个关系各自的外键间的歧义。

                    Example NvsN via model as connection_table: users <-> follows <-> users

                        class Follow(db.Model):
                            __tablename__ = 'follows'
                            follower_id = db.Column(db.Integer, db.ForeignKey('users.id'), primary_key=True)
                            followed_id = db.Column(db.Integer, db.ForeignKey('users.id'), primary_key=True)
                            timestamp = db.Column(db.DateTime, default=datetime.utcnow)

                    关注、被关注关系的设计：
                    # from user perspective:
                    #   follow(...), following other users,
                    #               (from other users' perspective) followed relationship
                    #                                                with Follow.follower_id/follower;
                    #   is_followed_by(...), being followed by other users,
                    #               (from other users' perspective) followers relationship
                    #                                                with Follow.followed_id/followed.
                    #
                    # in User.follow(self, user) method:
                        # parameter to Follow(...) is defined in User via db.relationship(...backref=...)
                    # in User.is_following(self, user) method:
                       # parameter to filter_by(...) is defined in Follow(...),
                       #                                           followed, followers are both Follow instances.
                       #

    D.4) Flask-SQLAlchemy 增删改查
        Usage Example 1. 增删改查
            # in hello.py
            ...

            # in Terminal
            export FLASK_APP=hello.py
            flask shell
            >>> from hello import db
                db.drop_all()
                db.create_all()
                from hello import Role, User
                admin_role = Role(name='Admin')
                mod_role = Role(name='Moderator')
                user_role = Role(name='User')
                user_john = User(username='john', role=admin_role)
                user_susan = User(username='susan', role=user_role)
                user_david = User(username='david', role=user_role)
                # db.session.add(admin_role)
                # db.session.delete(admin_role)
                db.session.add_all([admin_role, mod_role, user_role, user_john, user_susan, user_david])
                db.session.commit()  # or db.session.rollback()
                print(admin_role.id)
                print(mod_role.id)
                print(user_role.id)

                Role.query.all()
                User.query.all()

                query 过滤器：
                    filter(), filter_by(), order_by(), group_by(), limit(), offset()
                        # filter(...)       条件：table1.column1 = table2.column2
                        # filter_by(...)    条件：table1.column1 == value1

                query 执行方法：
                    all(), first(), first_or_404(), get(), get_or_404(), count(), paginate()
                    paginate() 方法返回一个 Pagination类对象。
                        Pagination类的属性：
                            items（当前页上的记录）, query（查找的源查询）, page（当前页数）,
                            pages（查询返回的总页数）, total（查询返回的总记录数量）, per_page,
                            has_prev, has_next, prev_num, next_num.

                        Pagination類的方法：
                            iter_pages(left_edge=2, left_current=2, right_current=5, right_edge=2),
                                        返回一个迭代器，在分页导航中显示的页数列表；
                            prev()上一页的分页对象；
                            next()下一页的分页对象。

                        Usage Example:
                            in  main/views.py:
                                page = request.args.get('page', 1, type=int)
                                pagination = user.posts.order_by(Post.timestamp.desc()).paginate(
                                    page, per_page=current_app.config['NA_BLOG_POSTS_PER_PAGE'], error_out=False)
                                # or
                                # pagination = Post.query.order_by(Post.timestamp.desc()).paginate(
                                #     page, per_page=current_app.config['NA_BLOG_POSTS_PER_PAGE'], error_out=False)
                                posts = pagination.items
                                return render_template('user.html', user=user, posts=posts, pagination=pagination)

                            !! call macro with endpoint must give parameters to the view function !!
                            in main/template/index.html,
                                {% import "_macros.html" as macros %}
                                after {% include '_posts.html' %}:
                                    <div class="pagination">
                                        {{ macros.pagination_widget(pagination, '.index') }}
                                    </div>
                            in main/template/user.html,
                                ...
                                <div class="pagination">
                                    {{ macros.pagination_widget(pagination, '.user', username=user.username) }}
                                </div>


                user_role = Role.query.filter_by(name='User').first()
                User.query.filter_by(role=user_role).all()
                User.query.get_or_404(id)
                user = User.query.filter_by(username=username).first_or_404()

                @property
                def followed_posts(self):
                    return Post.query.join(Follow, Follow.followed_id == Post.author_id).\
                                filter(Follow.follower_id == self.id)

                # str(...) 返回SQLAlchemy为查询生成的SQL查询语句。
                print(str(User.query.filter_by(role=user_role))

                关系与查询的处理方式类似，同时，
                    执行user_role.users，隐式的查询会调用all()方法，返回一个用户列表。
                    修改关系的设置加入 lazy='dynamic'，从而禁止自动执行查询，
                        此时 user_role.users将返回一个尚未执行的查询，因此可以在其上添加过滤器。

                >>> users = user_role.users
                >>> users
                [<User susan>, <User david>]
                >>> users[0].role
                <Role User>

                # lazy='dynamic'以后，关系上可以添加过滤器
                user_role.users[0] # still works
                user_role.users.order_by(User.username).all()
                user_role.users.count()

    D.5) Flask-SQLAlchemy 支持的SQL、NoSQL数据库
        MangoEngine 是 Object Document Mapping (ODM) 包。

        SQL数据库：关系型数据库，主键、外键、关系、实体、实体-关系图、表，记录。。。；
                    采用ACID范式；
        NoSQL数据库：如文档数据库、键-值对数据库，集合（==表）、文档（==记录）。。。；
                    减少了表、但是数据重复；
                    放宽了对ACID范式的要求。


    E) Flask-Migrate：数据库迁移。数据库迁移工具能跟踪数据库模式的变换，然后以增量的方式把变化应用到数据库中。
        Flask中两种方法：1. 直接用 Alembic （Alembic：蒸馏器）这个迁移框架；
                         2. 用Flask-Migrate扩展，这个扩展是对Alemic的轻量级包装，并与flask命令做了集成。

        Flask-SQLAlchemy 在只有数据库表不存在时，才会根据模型创建。
            所以如果有数据库模型的更改，即表结构的改动，需要先删除旧表，但会丢失数据，
            所以最好用Flask-Migrate来更新表。

        用 Flask-Migrate 管理数据库模型变化的步骤如下：
        （1）对模型做必要的修改；
        （2）执行 flask db migrate 命令，自动创建一个迁移脚本；
        （3）检查自动生成的脚本，根据对模型的实际改动进行调整；!! 重命名列的时候调整为drop_table(...) 然后 create_table(...) !!
        （4）把迁移脚本纳入版本控制；
        （5）执行 flask db upgrade 命令，把迁移应用到数据库中。
        如果前一个迁移还没提交，运行 flask db downgrade， 再重复上述步骤。

        pip install flask-migrate

        flask db init
        flask db migrate
        flask db upgrade
        flask db upgrade 15fe2ea317a5 # 15fe2ea317a5 is the head name

        flask db downgrade
        flask db stamp

        flask-migrate 安装在 venv pweb 中以后，
            D:\workspace\pweb\Scripts\alembic.exe
            D:\workspace\pweb\migrations\alembic.ini
                # alembic.ini make sure [alembic] section existing and script_location is set,
                    [alembic]
                    script_location = migrations

            alembic 命令：
            under D:\workspace\pweb\:
                alembic -c D:\workspace\pweb\migrations\alembic.ini heads
                alembic -c D:\workspace\pweb\migrations\alembic.ini merge heads
                alembic -c migrations\alembic.ini history

                # 生成从上次 flask db upgrade 后新的修改的 migrate script，  如 6e19a4658170_.py
                alembic -c migrations\alembic.ini revisions
                # similar to
                flask db migrate

            could add 1 unit test case to check if multiple heads in db via Alembic:
                from alembic.config import Config
                from alembic.script import ScriptDirectory

                def test_only_single_head_revision_in_migrations():
                    config = Config()
                    config.set_main_option("script_location", "nablog:migrations")
                    script = ScriptDirectory.from_config(config)

                    # This will raise if there are multiple heads
                    script.get_current_head()

                    # to check current heads
                    # print('current head in db via Alembic: {}'.format(script.get_current_head()))

            # ref: https://stackoverflow.com/questions/28392347/failed-no-config-file-alembic-ini-found
            # ref: https://stackoverflow.com/questions/22342643/alembic-revision-multiple-heads-due-branching-error
            # ref: https://blog.jerrycodes.com/multiple-heads-in-alembic-migrations/

        flask-migrate FAQ:
        (1) Scenario: rename columns in table Follow, run flask db migrate, flask db upgrade.
            flask db upgrade errors out:
                (pweb) D:\workspace\pweb>flask db upgrade
                INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
                INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
                INFO  [alembic.runtime.migration] Running upgrade 8aee64a56377 -> 15fe2ea317a5, empty message
                Traceback (most recent call last):
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\base.py", line 1244, in _execute_context
                    cursor, statement, parameters, context
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\default.py", line 552, in do_execute
                    cursor.execute(statement, parameters)
                sqlite3.OperationalError: Cannot add a NOT NULL column with default value NULL

                The above exception was the direct cause of the following exception:

                Traceback (most recent call last):
                  File "C:\Python36\lib\runpy.py", line 193, in _run_module_as_main
                    "__main__", mod_spec)
                  File "C:\Python36\lib\runpy.py", line 85, in _run_code
                    exec(code, run_globals)
                  File "D:\workspace\pweb\Scripts\flask.exe\__main__.py", line 9, in <module>
                  File "d:\workspace\pweb\lib\site-packages\flask\cli.py", line 966, in main
                    cli.main(prog_name="python -m flask" if as_module else None)
                  File "d:\workspace\pweb\lib\site-packages\flask\cli.py", line 586, in main
                    return super(FlaskGroup, self).main(*args, **kwargs)
                  File "d:\workspace\pweb\lib\site-packages\click\core.py", line 717, in main
                    rv = self.invoke(ctx)
                  File "d:\workspace\pweb\lib\site-packages\click\core.py", line 1137, in invoke
                    return _process_result(sub_ctx.command.invoke(sub_ctx))
                  File "d:\workspace\pweb\lib\site-packages\click\core.py", line 1137, in invoke
                    return _process_result(sub_ctx.command.invoke(sub_ctx))
                  File "d:\workspace\pweb\lib\site-packages\click\core.py", line 956, in invoke
                    return ctx.invoke(self.callback, **ctx.params)
                  File "d:\workspace\pweb\lib\site-packages\click\core.py", line 555, in invoke
                    return callback(*args, **kwargs)
                  File "d:\workspace\pweb\lib\site-packages\click\decorators.py", line 17, in new_func
                    return f(get_current_context(), *args, **kwargs)
                  File "d:\workspace\pweb\lib\site-packages\flask\cli.py", line 426, in decorator
                    return __ctx.invoke(f, *args, **kwargs)
                  File "d:\workspace\pweb\lib\site-packages\click\core.py", line 555, in invoke
                    return callback(*args, **kwargs)
                  File "d:\workspace\pweb\lib\site-packages\flask_migrate\cli.py", line 134, in upgrade
                    _upgrade(directory, revision, sql, tag, x_arg)
                  File "d:\workspace\pweb\lib\site-packages\flask_migrate\__init__.py", line 95, in wrapped
                    f(*args, **kwargs)
                  File "d:\workspace\pweb\lib\site-packages\flask_migrate\__init__.py", line 280, in upgrade
                    command.upgrade(config, revision, sql=sql, tag=tag)
                  File "d:\workspace\pweb\lib\site-packages\alembic\command.py", line 276, in upgrade
                    script.run_env()
                  File "d:\workspace\pweb\lib\site-packages\alembic\script\base.py", line 475, in run_env
                    util.load_python_file(self.dir, "env.py")
                  File "d:\workspace\pweb\lib\site-packages\alembic\util\pyfiles.py", line 90, in load_python_file
                    module = load_module_py(module_id, path)
                  File "d:\workspace\pweb\lib\site-packages\alembic\util\compat.py", line 177, in load_module_py
                    spec.loader.exec_module(module)
                  File "<frozen importlib._bootstrap_external>", line 678, in exec_module
                  File "<frozen importlib._bootstrap>", line 219, in _call_with_frames_removed
                  File "migrations\env.py", line 96, in <module>
                    run_migrations_online()
                  File "migrations\env.py", line 90, in run_migrations_online
                    context.run_migrations()
                  File "<string>", line 8, in run_migrations
                  File "d:\workspace\pweb\lib\site-packages\alembic\runtime\environment.py", line 839, in run_migrations
                    self.get_context().run_migrations(**kw)
                  File "d:\workspace\pweb\lib\site-packages\alembic\runtime\migration.py", line 362, in run_migrations
                    step.migration_fn(**kw)
                  File "D:\workspace\pweb\migrations\versions\15fe2ea317a5_.py", line 21, in upgrade
                    op.add_column('follows', sa.Column('followed_id', sa.Integer(), nullable=False))
                  File "<string>", line 8, in add_column
                  File "<string>", line 3, in add_column
                  File "d:\workspace\pweb\lib\site-packages\alembic\operations\ops.py", line 1904, in add_column
                    return operations.invoke(op)
                  File "d:\workspace\pweb\lib\site-packages\alembic\operations\base.py", line 345, in invoke
                    return fn(self, operation)
                  File "d:\workspace\pweb\lib\site-packages\alembic\operations\toimpl.py", line 131, in add_column
                    operations.impl.add_column(table_name, column, schema=schema)
                  File "d:\workspace\pweb\lib\site-packages\alembic\ddl\impl.py", line 231, in add_column
                    self._exec(base.AddColumn(table_name, column, schema=schema))
                  File "d:\workspace\pweb\lib\site-packages\alembic\ddl\impl.py", line 134, in _exec
                    return conn.execute(construct, *multiparams, **params)
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\base.py", line 988, in execute
                    return meth(self, multiparams, params)
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\sql\ddl.py", line 72, in _execute_on_connection
                    return connection._execute_ddl(self, multiparams, params)
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\base.py", line 1050, in _execute_ddl
                    compiled,
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\base.py", line 1248, in _execute_context
                    e, statement, parameters, cursor, context
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\base.py", line 1466, in _handle_dbapi_exception
                    util.raise_from_cause(sqlalchemy_exception, exc_info)
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\util\compat.py", line 398, in raise_from_cause
                    reraise(type(exception), exception, tb=exc_tb, cause=cause)
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\util\compat.py", line 152, in reraise
                    raise value.with_traceback(tb)
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\base.py", line 1244, in _execute_context
                    cursor, statement, parameters, context
                  File "d:\workspace\pweb\lib\site-packages\sqlalchemy\engine\default.py", line 552, in do_execute
                    cursor.execute(statement, parameters)
                sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) Cannot add a NOT NULL column with default value NULL
                [SQL: ALTER TABLE follows ADD COLUMN followed_id INTEGER NOT NULL]
                (Background on this error at: http://sqlalche.me/e/e3q8)

            manually changed 15fe2ea317a5_.py, however set down_revision wrong: down_revision = 'ad6833d9650f'
                # revision order: ad6833d9650f -> 8aee64a56377 -> 15fe2ea317a5
                #   !! should be 8aee64a56377 then no alembic -c migrations/alembic.ini merge heads !!

            run flask db upgrade, it errors out:
                (pweb) D:\workspace\pweb>flask db upgrade
                    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
                    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
                    ERROR [root] Error: Multiple head revisions are present for given argument 'head';
                    please specify a specific target revision, '<branchname>@head' to narrow to a specific head,
                    or 'heads' for all heads

            root-cause: columns-rename works not 100% correct in flask-migrate,
                        manual-change of migration script caused multiple heads.

            fix: find out alembic.ini and update its content:
                    D:\workspace\pweb\migrations\alembic.ini
                    [alembic]
                    script_location=migrations
                 change the wrong_migration_script to def upgrade():pass and def downgrade():pass ;
                 alembic -c D:\workspace\pweb\migrations\alembic.ini merge heads ;
                 flask db upgrade ;
                 done.

    F) Flask-Mail: Python有标准库smtplib可发送邮件，Flask-Mail 包装了 smtplib 能更好的与Flask集成。
        Flask-Mail 连接到 Simple Mail Tranfer Protocol (SMTP)服务器，把邮件交给这个服务器发送。
        Flask-Mail SMTP 服务器的配置和默认值， 使用 Gmail 的配置和默认值：
            MAIL_SERVER: localhost,             smtp.googlemail.com
            MAIL_PORT:   25,                    587
            MAIL_USE_TLS: False
            MAIL_USE_SSL: False
            MAIL_USERNAME: None
            MAIL_PASSWORD: None
        上述配置可以在code中设置： app.config[...]  = ... 。

        MAIL_USERNAME, MAIL_PASSWORD 最好放在环境变量里。
        NA_BLOG_ADMIN （email of admin) 也放在环境变量里。
        # export MAIL_USERNAME =...
        set MAIL_USERNAME =...

        pip install flask_mail

        Usage Example:
            # in flask shell:
            from flask_mail import Message
            from hello import mail
            msg = Message('test email', sender='from_na_blog@gmail.com', recipients=['liuna_liuna@qq.com'])
            msg.body = 'This is the plain text body.'
            msg.html = 'This is the <b>HTML</b> body.'
            with app.app_context():
                mail.send(msg)

    G) Flask-Login：管理已登陆用户的session
            Flask-Login 是一个非常有用的小型扩展，专门用于管理用户身份验证系统中的验证状态，且不依赖于特定的身份验证机制。
            Flask-Login 运转需要应用中有 User 对象，且User模型必须实现以下属性和方法：
                is_authenticated, is_active, is_anonymous, get_id()
            使用 Flask-Login 两种方法：1. 在User模型中实现以上属性和方法；
                                      2. 用Flask-Login 提供的UserMixin类。UserMixin 包含默认实现，能满足多数需求。
            Flask-Login 中定义了 current_user，在 view functions and templates 中自动可用。
                          可以用 current_user.is_authenticated 判断当前用户是否登录。

            Flask-Login 中用户登录过程：
            （1）用户点击 Log In 链接，访问 http://localhost:5000/auth/login， 处理这个URL的函数返回登录表单模板；

            （2）用户输入用户名和密码，点击提交按钮。再次调用同一处理函数，不过这一次处理的是POST请求，不是GET请求。
                a.处理函数验证通过表单提交的凭据，然后调用Flask-Login的 login_user() 函数，登入用户；
                b.login_user() 函数把用户的ID以字符串的形式写入用户会话；
                c.处理函数重定向到首页；

            （3）浏览器收到重定向响应，请求首页。
                a.调用首页的视图函数，渲染主页的 Jinja2 模板；
                b.在渲染这个Jinja2 模板的过程中，首次引用Flask-Login的 current_user；
                c.该请求还没有给上下文变量 current_user 赋值，因此调用Flask-Login内部的_get_user()函数，找出用户是谁；
                d._get_user()函数检查用户会话中有没有用户ID，如果没有，返回一个Flask-Login的 AnonymousUser 实例，
                    如果有ID，调用应用中使用 user_loader 装饰器注册的函数，传入用户ID；
                e.应用中的 user_loader 处理函数从数据库中读取用户，将其返回。
                    Flask-Login 把返回到用户对象赋值给当前请求的 current_user 上下文变量。
                f.模板收到新赋值的 current_user。

            pip install flask_login

            Usage Example:
                define class LoginForm in auth/forms.py;
                define login template in templates/auth/login.html;
                update User model in models.py to add email column;
                change index() in auth/views.py, add login(), logout();
                add login_manager in app/__init__.py;
                update template/base.html add Log In/Log Out navigation button;
                update template/index.html to use current_user.is_authenticated;
                migrate db via
                    flask db migrate
                    flask db upgrade
                test in flask shell:
                    u = User(email='john@example.com', username='john', password='cat')
                    db.session.add(u)
                    db.session.commit()
                    # then try http://127.0.0.1:5000/auth/login in browser.

            # 在用户详情页面显示地点：
            # in app/templates/user.html
                {% if user.name or user.location %}
                <p>
                    {% if user.name %}{{ user.name }}{% endif %}
                    {% if user.location %}
                        From <a href="http://maps.google.com/?q={{ user.location }}">{{ user.location }}</a>
                    {% endif %}
                </p>
                {% endif %}

                # could change to https://map.baidu.com/?q={{ user.location }} if couldn't open google maps.

            # 设置用户头像
            (1) 用 gravatar 网站生成头像：
                https://secure.gravatar.com/avatar/<md5hash_of_email>?s=size&d=default&r=rating
                or https://www.gravatar.com/avatar/<md...
                    如 https://secure.gravatar.com/avatar/d4c74594d841139328695756648b6bd6?d=identicon&r=g&s=100 。
            (2) 用 bootstrap 的CSS样式 profile-thumbnail, profile-header 显示：
                in app/templates/users.html,
                   app/templates/index.html,
                   app/templates/_posts.html:
                    <img class="img-rounded profile-thumbnail" src="{{ user.gravatar(size=256) }}">
                    <div class="profile-header">
                        ...
                    </div>


    F) Werkzeug：计算密码的散列值并进行核对
            存储在数据库中的用户密码不能是用户的原始密码，而是hash of password。
                original password + salt -> through multiple uni-directional password convertion -> hash of the password.

            可以用 werkzeug.security generate_password_hash 来生成密码散列，用 check_password_hash 来核对。
                也可以用 bcrypt 和 Passlib 计算密码的散列值。

            Usage Example:
                # in models.py:
                    from werkzeug import generate_password_hash, check_password_hash

                    Class User(db.Model):
                        ...
                        password_hash = db.Column(db.String(128))

                        @property
                        def password(self):
                            raise AttributeError('Password is not a readable attribute')

                        @password.setter
                        def password(self, password):
                            self.password_hash = generate_password_hash(password)

                        def verify_password(self, password):
                            return check_password_hash(self.password_hash, password)

                # check in flask shell:
                    >>> u = User()
                    >>> u.password = 'cat'
                    >>> u.password
                    Traceback (most recent call last):
                      File "<console>", line 1, in <module>
                      File "D:\workspace\pweb\app\models.py", line 47, in password
                        raise AttributeError('Password is not a readable attribute')
                    AttributeError: Password is not a readable attribute
                    >>> u.password_hash
                    'pbkdf2:sha256:150000$ju9iskX6$c693dd143510740e6bb7fcda074f41bb98cb17437608d8177646716304af0c32'
                    >>> u.verify_password('cat')
                    True
                    >>> u.verify_password('dog')
                    False
                    >>> u2 = User()
                    >>> u2.password = 'cat'
                    >>> u2.password_hash
                    'pbkdf2:sha256:150000$Ft6latWs$867a26e074f5e65088d57a32e07990191eac4405586c4e699a2d81e6a7188691'
                    >>> u.password_hash == u2.password_hash
                    False

                set FLASK_APP = nablog.py
                flask shell
                >>> from app.models import Permission
                >>> r = Role(name='User')
                >>> r.add_permission(Permission.FOLLOW)
                >>> r.add_permission(Permission.WRITE)
                >>> r.has_permission(Permission.FOLLOW)
                True
                >>> r.reset_permissions()
                >>> r.has_permission(Permission.FOLLOW)
                False

    H) itsdangerous：生成并核对 加密安全令牌
        # in app/models.py:
            from itsdangerous import TimedJSONWebSignatureSerializer as Serializer

            def generate_confirmation_token(self, expiration=600s): # 10 minutes
                s = Serializer(current_app.config['SECRET_KEY'], expires_in=expiration)
                return s.dumps({'confirm': self.id}).decode('utf-8')

            def confirm(self, token):
                s = Serializer(current_app.config['SECRET_KEY'])
                try:
                    data = s.loads(token.encode('utf-8'))
                except:
                    return False
                if data.get('confirm') != self.id:
                    return False
                self.confirmed = True
                db.session.add(self)
                return True

    I) shell： Flask集成了Python shell
        Example:
            # to integrate Python shell
            @app.shell_context_processor
            def make_shell_context():
                return dict{Role=Role, User=User, db=db}

    J) click：简单易用的命令行解析工具
        Click is a simple Python module inspired by the stdlib optparse to make writing command line scripts fun.
        Unlike other modules, it's based around a simple API that does not come with too much magic
            and is composable.

        Example:
        @app.cli.command
        @click.option('--coverage/--no-coverage', default=False, help='Run tests under code coverage.')
        @click.argument('test_names', nargs=-1)
        def test(test_names):
            ""Run the unit tests."""
                import unittest
                if test_names:
                    ...
                ...

    K) faker: 生成虚拟数据, fakers 中用 Faker 类生成虚拟数据。
              字段包括： email(), user_name(), name(), city(), text(), past_date(), etc.
        Example:
            pip install faker

            from faker import Faker
            def users(count=N):
                fake = Faker()
                i = 0
                while i<count:
                    u = User(email=fake.email(),
                             username=fake.user_name(),
                             ...)
                    db.session.add(u)
                    try:
                        db.session.commit()
                        i += 1
                    except IdentityError:
                        db.session.rollback()

    L) Flask-PageDown：用 Flask 包装的 PageDown，把 PageDown 集成到Flask WTF 表单中。
       PageDown:       使用 JavaScript 实现的客户端 MarkDown 到 HTML 转换程序。
       MarkDown：      使用 Python 实现的服务器端 MarkDown 到 HTML 的转换程序。
       Bleach：        使用 Python 实现的 HTML 清理程序。

        pip install flask_pagedown markdown bleach

    M) Flask-HttpAuth 提供了 HTTP 身份验证协议的封装，把协议的细节隐藏在装饰器之中，
            类似于 Flask-Login 提供的 login_required 装饰器。

            用 Flask-Login 实现了应用的登录功能，数据存储在用户会话中，默认情况下，Flask 把会话保存在客户端 cookie 中。
            而 REST 架构要求无状态，如果使用 cookie，不现实，因为 Web浏览器之外的客户端很难提供对 cookie 的支持。

        pip install flask_httpauth
        app/api/authentication.py 中由 auth = HTTPBasicAuth() 实现身份验证，包括：
            @auth.verify_password
            # a callback function used in @auth.verify_password
            def verify_password(email_or_token, password):
                ...
                    when @auth.verify_password failed, it will return 401 error: Unauthorized.
                    # issue a request with a bad token
                    response = self.client.get('/api/v1/posts/', headers=self.get_api_headers('notoken', ''))
                    self.assertEqual(response.status_code, 401)

            @auth.error_handler
            # overwrite 401 error when credentials are invalid in HttpBasicAuth
                ...

            @api.before_request
            @auth.login_required
                ...

            @api.route('/tokens', methods=['POST']
                ...


    N) httpie HTTP客户端，可以用来在命令行中测试 Web 服务。

        pip install httpie

        !! pay attention to the / at the end of URL, could introduce redirection issue. !!
        >>> http --json --auth santosalexandria@yahoo.com:password GET http://127.0.0.1:5000/api/v1/posts/
            http --json --auth santosalexandria@yahoo.com:password POST http://127.0.0.1:5000/api/v1/posts/ \
            "body=I'm adding a post form the *command line*."

            http --json --auth santosalexandria@yahoo.com:password POST http://127.0.0.1:5000/api/v1/tokens/
            http --json --auth eyJhbGciOiJIUzUxMiIsImlhdCI6MTU2NjIwNTc4NSwiZXhwIjoxNTY2MjA2Mzg1fQ.eyJpZCI6MTA3fQ.\
            aV7Xo0jrIh10CSdYtcOtUmL_zpLFzPmqFWiVmCNWwcCd0vv0wt0II3q5G8lh4-0u19v2hs1bQYnfh2pSuhV6Lw: POST \
            http://127.0.0.1:5000/api/v1/posts/ "body=I'm adding a 2nd post form the *command line*."

    O) Flask-Admin 提供一个 admin 平台，适合于小型快速开发，例如博客、小型论坛、小型官网等等。

        from flask_admin import Admin
        admin = Admin(app, name='cleanblog', template_mode='bootstrap3')    # default template_mode is bootstrap2

        # could see admin page in browser via http://127.0.0.1:5005/admin/

    # ref: https://segmentfault.com/a/1190000013073352


3.13) Flask开发的大型应用的结构
以一个blog system为例，
    配置放在 config.py中；
    程序入口在 <appname>.py 中如 nablog.py;
    应用相关的放在 app/ 下: __init__.py, templates/, static/, email.py, models.py, decoratros.py, exceptions.py, faker.py;
                            blueprint code 在 main/ 下：main/__init__.py,
                                                        main/errors.py,
                                                        main/forms.py,
                                                        main/views.py,
                                               auth/...,
                                               api/...,
    路由提取到 blueprint 实现，在 main/__init__.py, main/errors.py, main/views.py, auth/..., api/auth/..., api/... 里。
    数据库迁移放在 migrations/ 下；
    单元测试放在 tests/ 下，coverage, profile 的 check 信息放在 nablog.py 中；
    依赖包放在 requirements.txt, requirement/common.txt, requirements/... 中；
    部署的信息放在 boot.sh, Dockerfile, .env, .env-mysql, docker-compose.yml 中；

    app 改为由工厂函数创建：
        def create_app(config_name):
            app = Flask(__name__)
            app.config.from_object(config[config_name])
            config[config_name].init_app(app)
    app 改为由工厂函数创建以后，可以用蓝图在全局作用域中定义路由。

    Notes:
    3.13.1) in sub-class of unittest.TestCase:
            either remove __init__ or in exact __init__(self, *args, **kwargs) format.

    3.13.2) 在 PyCharm 的 Terminal下运行的时候，
            set FLASK_APP=nablog.py
            set FLASK_CONFIG=testing
            flask test

            # or
            set FLASK_APP=nablog.py
            set FLASK_CONFIG=
            flask run

            # or
            set FLASK_APP=nablog.py
            flask shell

    3.13.3) update requirements.txt:
        # to install pip if pip is missing or errors out
        easy_install pip

        pip list
        pip freeze > requirements.txt
        requirements 根据开发、产品环境的不同而不同，放在
            requirements/common.txt,
            requirements/dev.txt,
            requirements/prod.txt,
            ...
            中。

3.14) API框架 REST
    Rich Internet Application (RIA)：富互联网应用。在RIA中，服务器是为客户端提供数据存取服务。
        在这种模式下，服务器变成了Web服务或API。
    RIA 可以采用多种协议与Web服务通信，如RPC协议例如 XML-RPC，以及由其衍生的SOAP协议。
        现在流行的Web服务的框架是 Representational State Transfer (REST)。

    REST框架的6大特点：资源就是一切 + HTTP协议
        客户端-服务器
        无状态
        缓存
        接口统一
        系统分层
        按需编程
    REST框架常用的编码协议：JSON、XML。JSON常用。

    例子：该Blog应用的API资源
    资源URL                       方法          说明
    /users/<int:id>                 GET
    /users/<int:id>/posts/          GET
    /users/<int:id>/timeline/       GET
    /posts/                         GET
    /posts/                         POST
    /posts/<int:id>                 GET
    /posts/<int:id>                 PUT
    /posts/<int:id>/comments/       GET
    /posts/<int:id>/comments/       POST
    /comments/                      GET
    /comments/<int:id>              GET

    为了保证兼容性，REST API的URL上加上版本信息：
    例如：
        from .api import api as api_blueprint
        app.register_blueprint(api_blueprint, url_prefix='/api/v1')

    REST框架的URL的处理函数 view functions 与 Web应用的 view functions 类似，
        REST    返回 JSON 格式的数据。
        Web应用 渲染模板或者跳转到新页面。

3.15) performance
    A) Flask-SQLAlchemy 提供了一个选项，可以记录一次请求中与数据库查询相关的统计数据。
                     这个功能使用 @main.after_request 调用 get_debug_queries() 实现。

                     get_debug_queries() 函数返回一个列表，其元素是请求中执行的查询，每个查询的属性包括：
                        statement, parameters, start_time, end_time, duration, context（查询在源码中的位置）

        # in config.py:
            SQLALCHEMY_RECORD_QUERIES = True
            NA_BLOG_SLOW_DB_QUERY_TIME = os.environ.get('NA_BLOG_SLOW_DB_QUERY_TIME') or 0.5
        # in app/main/views.py
            from flask_sqlalchemy import get_debug_queries

            @main.after_request
            def after_request(response):
                for query in get_debug_queries:
                    ....
                return response

    B) Werkzeug 通过 ProfilerMiddleware中间件 提供了一个源码分析器，可以用来查找应用中执行最慢的部分。
            步骤：
            （1）定义一个CLI函数：
                @app.cli.command()
                @click.option('--length',...)
                @click.option('--profile-dir'...)
                def profile(length, profile-dir):
                ...
            （2）在 profile(...) 中把 ProfilerMiddleware中间件 attach to app.wsgi_app 上，然后 app.run(...).
            （3）运行 flask profile 后，默认每条请求的分析数据会写到控制台；
                      如果设置了 --profile-dir，数据会保存到指定目录下的一个文件中。

            <=> However, flask profile --profile-dir=./profiler doesn't work:
                    #   Warning: Silently ignoring app.run() because the application is run
                    #       from the flask command line executable.
                    #       Consider putting app.run() behind an if __name__ == "__main__" guard to silence this warning.
                    #
                write profiling code directly behind if __name__ == "__main__" and before app.run() works.
                #   profile_dir './tmp/profiler' must exist.
                #
                # from werkzeug.contrib.profiler import ProfilerMiddleware
                # app.wsgi_app = ProfilerMiddleware(app.wsgi_app, restrictions=['--length=15'], profile_dir='./tmp/profiler')


#
# Flask 启动、和其他工具的集成
#
1. 1）Nginx、Gunicorn 和 Flask 的关系
Nginx：  处理静态文件，可以缓存一些动态内容，反向代理，负载均衡，对恶意访问加黑名单等等；

Gunicorn：Python实现的网关，实现了 Web Server Gateway Interface (WSGI),
          擅长于管理多进程，有进程挂了Gunicorn可以再拉起来、防止服务器长时间停止服务，
          还可以动态调整worker数量，请求多的时候增加worker的数量、请求少的时候减少，
          这就是所谓的pre-fork模型。

Flask：  内置了一个webserver，给开发者用的；
        不适合生产环境用、单进程(用不了多核）、难扩展（失败了就挂掉）。

生产环境中常用的部署：
    多Nginx + 多Gunicorn + Flask App，Gunicorn用supervisor管理。


# ref: https://www.zhihu.com/question/297267614 https://www.zhihu.com/question/297267614
# ref: 使用了Gunicorn或者uWSGI,为什么还需要Nginx？https://www.zhihu.com/question/30560394

2）gunicorn 配置 nginx
    譬如in /etc/nginx/sites-enabled/wepub:
        server {
            listen 80;
            root /www/demo;
            server_name example.org;

            location / {
                proxy_pass http://127.0.0.1:8000;   # 转发gunicorn的运行地址
            }
        }

    另外可以扩展反向代理部分：
        location / {
            proxy_pass  http://localhost:8000/; # 转发gunicorn的运行地址
            proxy_redirect off;

            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
     静态文件：
        location ~ ^\/static\/.*$ {
            root /www/demo；
        }

# ref: uWSGI和Gunicorn对比实践笔记 https://zhuanlan.zhihu.com/p/50857407

3）用supervisor运行一个program
    # install
    sudo apt-get install supervisor

    # 创建配置文件 /etc/supervisor/conf.d/demo.conf
    [program:demo]
    command=/www/demo/venv/bin/gunicorn -c /pushy/blog/gconfig.py run:app
    directory=/www/demo     # 项目目录
    user=root
    autorestart=true
    startretries=3

    # 保存配置文件以后，需要更新配置文件
    supervisorctl update

    # 启动demo进程
    supervisorctl start demo








# ref: supervisor的安装与简单介绍 https://www.cnblogs.com/Dicky-Zhang/p/6171954.html
# ref: supervisor详解 https://www.cnblogs.com/shijingjing07/p/9395110.html




#
# 2。Gunicorn 知识点
#
WSGI HTTP 服务器，pre-fork worker模式：擅长于管理多进程，所以提升了服务器处理负载的能力。

# install
apt-get install gunicorn
# or
pip install gunicorn

# start
gunicorn -w 2 -b 0.0.0.0:8000 test:application
# or
gunicorn -c gunicorn.conf.py test:application

# simple wsgi interface example in test.py
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html'])
    return b'<h1>Hello, web!</h1>'

    -w worker 数量，推荐 num_of_cpu_cores * 2 + 1,
    -b bind，与指定的socket进行绑定，
    -k WorkerClass, 工作进程类型，包括 sync(default), gevent, eventlet, tornado, gtheread, gaiohttp.
    -c Config，配置文件，一个.py文件，可以实现复杂的逻辑。

# example of gunicorn.conf.py
    from gevent import monkey
    monkey.patch_all()
    import multiprocessing
    debug = True
    loglevel = 'debug'
    bind = '127.0.0.1:5000'     # 绑定与 Nginx 通信的端口
    pidfile = 'log/gunicorn.pid'
    logfile = 'log/debug.log'
    workers = multiprocessing.cpu_count() * 2 + 1
    worker_class = 'gevent'     # 默认是sync，阻塞模式，最好选择gevent模式






# ref: Gunicorn使用详解 https://www.cnblogs.com/shijingjing07/p/9110619.html
# ref: nginx+uwsgi 和nginx+gunicorn区别、如何部署 https://www.jianshu.com/p/be2b587a900e
# ref: 深入理解uwsgi和gunicorn网络模型 https://blog.csdn.net/shudaqi2010/article/details/71172683

#
# 3. Flask 原理、语法
#


# ref: Flask源码解析:Flask应用执行流程及原理 https://www.cnblogs.com/weihengblog/p/9490561.html


