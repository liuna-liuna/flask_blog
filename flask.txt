#
# Flask 知识点
#
1. coding

2. how to run
    # on Windows, use export for Linux
        (pweb) D:\workspace\pweb> set FLASK_APP=hello.py
        (pweb) D:\workspace\pweb> flask run
        # open http://127.0.0.1:5000/ in browser.
        # http://127.0.0.1:5000/user/Dave

        # 只接受运行flask的本机的连接
        flask run

        # 接受同一网络中的其他计算机发送的连接
        flask run --host 0.0.0.0


    set FLASK_DEBUG=1 doesn't work on Windows for following versions:
        > flask --version
        Python 3.6.4
        Flask 1.1.1
        Werkzeug 0.15.5

3. architecture, diagram, mechanism
3.0) overview
    Flask: microframework, based on werkzeug and jinja2;
           built-in wsgi.

    data flow:
            request comes in <- Request obj: a LocalProxy obj, in rqx_local_stack of LocalStack type,
                                App obj:     a LocalProxy obj, in app_local_stack of LocalStack type,

         -> route,           <- @app.route(url, method=..., ...)
                                or app.url_map_rule(url, endpoint, function).

         -> response

    separate business logic and presentation logic:
        business logic      <- view function
        presentation logic  <- template





3.1) globals (within threads, routines)
    Flask 上下文全局变量：
        current_app: 在应用上下文中使用，     当前应用的应用实例。
        g:           。。。应用上下文。。。， 处理请求时 用作临时存储 的对象，每次请求都会重设这个变量。
        request:     。。。请求上下文。。。， 请求对象，封装了客户端发出的HTTP请求中的内容。
        session:     。。。请求上下文。。。， 用户会话，值为一个字典，存储请求之间需要“记住”的值。

    request attributes and methods:
        form, args, values（form和args的合集）,
        cookies, headers, method（HEAD, OPTIONS方法由Flask自动处理）,
        files, blueprint, endpoint（处理请求的Flask端点的名称，Flask把视图函数的名称用作路由端口的名字）,
        scheme, host, remote_addr,
        path, query_string, full_path(path和query_string的合集），
            base_url, url（baseurl和query_string的合集）,
        environ.
        get_data(), get_json(), is_secure() （是否用HTTPS）。

    request hook:
        @before_request(...),
        @before_first_request(...)： 可用来添加服务器初始化任务。
        @after_request(...)：如果没有未处理的异常抛出，在每次请求之后运行。
        @teardown_request(...)：即使有未处理的异常抛出，也在每次请求之后运行。
    一般在 request hook 和 view function 之间用g来共享数据。
    例如：before_request 中从数据库中加载已登录用户，并保存在g.user中，
            在view function中可以通过g.user获取用户。

    view function and make_response(...) returns a response object.
    response attributes and methods:
        status_code, headers, content_length, content_type,
        set_cookie(), delete_cookie(), set_data(), get_data().
    Example:
        @app.route('/')
        def index():
            return '<h1>Bad request</h1>'

            # or
            return '<h1>Bad request</h1>', 400

            # or
            from flask import make_response
            response = make_response('<h1>This document carries a cookie!</h1>')
            response.set_cookie('answer', '42')
            return response

    response的快捷方式：redirct(...), abort(...); abort不会把控制权交还给调用它的函数，而是抛出异常。
    Example：
        from flask import redirect

        @app.route('/')
        def index():
            return redirect('http://www.example.com')

        from flask import abort

        @app.route('/user/<id>')
        def get_user(id):
            user = load_user(id)
            if not user:
                abort(404)
            return '<h1>Hello, {}</h1>'.format(user.name)


3.2) configuration


3.3) route
    静态路由：'/user'：静态路由的例子；
             'static/<filename>'：Flask自动生成，例如 url_for('static', filename='css/styles.css', _external=True)，
                                  将得到http://localhost:5000/static/css/styles.css。
    dynamic routing:
                     '/user/<name>'：动态路由；
                     url_for('index'): 得到 / ;
                     url_for('index', _external=True)：得到 http://localhost:5000/ ;
                     url_for('user', name='john', _external=True)：得到 http://localhost:5000/user/john 。

3.4) template
    template:        a file including static part and dynamic part (placeholder).
    template engine: jinja2.
    render:          the process to replace placeholder using value, return response.

    jinja2 可以识别出所有类型的变量，包括列表、字典和对象。
        <p>A value from a dictionary: {{ mydict['key'] }}.</p>
        <p>A value from a list: {{ mylist[3] }}.</p>
        <p>A value from a list, with a variable index: {{ mylist[myintvar] }}.</p>
        <p>A value from an object's method: {{ myobj.somemethod() }}.</p>

    jinja2 过滤器：
        Hello, {{ name|capitalize }}

        safe（渲染值时不转义。默认Jinja2会转义，为了安全考虑，例如<h1>转义为&lt;h1&gt;）,
        capitalize, lower, upper, title（每个单词首字母大写）, trim, striptags（把HTML标签删掉）.

        ！！不要在不可信的值上用safe，例如用户在表单中输入的文本！！

    template 支持if, for, macro定义和使用， import, 继承via block, extends, super()。

3.5) blueprint
3.6) authentication
3.7) database connection

3.8) flash(...), get_flashed_messages()

3.9) security

3.10) test
3.10.1) Example 1. use built-in unittest to do test.
    A) code-snippet
        import unittest
        tests = unittest.TestLoader().discover('tests') # tests/ is the directory under which test_basics.py locates.
        unittest.TextTestRunner(verbosity=2).run(tests)

    B)
    C) FAQ:
        C.1) in sub-class of unittest.TestCase:
            either remove __init__ or in exact __init__(self, *args, **kwargs) format, otherwise:
              TypeError: __init__() takes 1 positional argument but 2 were given

        class BasicsTestCase(unittest.TestCase):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)
                print('[TO BE REMOVED] in __init__ function in BasicsTestCase class.')

    ref: https://stackoverflow.com/questions/47445137/unittest-selenium-init-takes-1-positional-argument-but-2-were-given
    ref: https://stackoverflow.com/questions/42790980/python-unittest-throws-uncaught-typeerror-init-takes-1-positional-argumen/42791106


3.11) distribution

3.12) extension
    A) Flask-Bootstrap: Bootstrap是twitter开源的一个用于开发web的客户端框架，提供用户界面组件，兼容桌面和移动浏览器。
                        服务器只是提供引用了CSS、Javascript的response，
                              并在HTML、CSS、Javascript代码中实例化所需的用户界面元素。

        pip install flask-bootstrap
        其 boostrap/base.html中，定义了如下block：
            doc, html, html_attribs, head, title, metas（一组meta标签）,
            styles（CSS声明）, body, body_attribs, navbar, content, scripts（文档底部的JavaScript声明）.

         Usage example:
            # in hello.py
            from flask-bootstrap import Bootstrap
            bootstrap = Bootstrap(app)

            # in templates/base.html
            {% extends bootstrap/base.html %}

        Bootstrap 中 data-toggle 和 data-target 的作用：
            定义 data-target 指定的元素以 data-toggle 指定的形式显示。
            HTML5 运行用户自定义标签，自定义标签大多以 data- 开头。
                Bootstrap 中，data-toggle指事件以什么触发，如 modal, toggle, dropdown, popover, tooltip etc.
                              data-target指事件的目标，如 id属性或者 class属性。

        # ref: data-toggle与data-target是什么作用 https://blog.csdn.net/d295968572/article/details/56667863
        # ref: 关于bootstrap的data-toggle和data-target https://blog.csdn.net/weixin_37986839/article/details/76593332

    B) Flask-Moment：Moment.js 是一个优秀的 JavaScript 开发的在客户端浏览器中渲染日期和时间的开源库，
                     Flask-Moment 是一个Flask扩展，能简化把 Moment.js 集成到 Jinja2模板中的过程。
                     Flask-Moment 依赖于 Moment.js, jQuery.js。jQuery.js 在 Bootstrap 中已引入。
                     Flask-Moment 实现了 Moment.js 中的 format(), fromNow(), fromTime(), calendar(), valueOf()
                                  和 unix() 等方法。
                     Flask-Moment 假定服务器端应用处理的时间戳是“纯正的”datetime对象，且使用UTC表示。

        pip install flask-moment
        Usage example:
            # in hello.py
            from datetime import datetime
            from flask-moment import Moment
            moment = Moment(app)

            @app.route('/')
            def index():
                return render_template('index.html', current_time=datetime.utcnow())

            # in templates/base.html
            {% block scripts %}
            {{ super() }}
            {{ moment.include_moment() }}
            {{ moment.locale('zh-cn') }}       # add locale language support, zh-cn: Chinese, es: Spanish
            {% endblock %}

            # in templates/index.html
            <p>The local date and time is {{ moment(current_time).format('LLL') }}.</p>
            <p>That was {{ moment(current_time).fromNow(refresh=True) }}.</p>


    C) Flask-WTF：创建Web表单等，这个扩展对独立的 WTForms 包进行了包装，方便集成到Flask应用中。
                    WTForms 包本身可与多个框架集成。

            pip install flask-wtf

            app.config['SECRET_KEY'] is needed to protect against CrossSiteRequestForgery (CSRF) attack,
                and Flask generates token for each form and stores into session.

            配置 SECRET_KEY 可以用 app.config['SECRET_KEY']，最好是放在环境变量里。
            # export SECRET_KEY=...
            set SECRET_KEY=...

        WTForms 支持的HTML标准字段：
            BooleanField, HiddenField, PasswordField, DateField, DateTimeField,
            FileField, MutileFileField, DecimalField, IntegerField, FloatField,
            StringField, TextAreaField, RadioField, SelectField, SelectMultipleField,
            FieldList, FormField, SubmitField.

        WTForms 内建的验证函数：
            InputRequired （确保转换类型前字段中有数据）， DataRequired （确保转换类型后字段中有数据），
            URL, UUID, Email, IPAddress, MacAddress, EqualTo, Length, NumberRange, Regexp,
            Optional （允许字段中没有输入，将跳过其他验证函数）, AnyOf, NoneOf.

        手动处理、渲染 forms 需要重复coding，用 bootstrap 的wtf.quickform(form)。

        Usage example:
            # in hello.py
            from flask import Flask, render_template, redirect, url_for
            from flask_wtf import FlaskForm
            from wtforms import StringField, SubmitField
            from wtforms.validators import DataRequired

            app.config['SECRET_KEY'] = '...'

            class NameForm(FlaskForm):
                name = StringField('What is your name?', validators=[DataRequired()])
                submit = SubmitField('Submit')

            @app.route('/', methods=['GET', 'POST'])
            def index():
                name, form = None, NameForm()
                if form.validate_on_submit():
                    name = form.name.data
                    form.name.data = ''
                    return redirect(url_for('.index'))
                else:
                    return render_template('index.html', current_time=datetime.utcnow(), form=form, name=name)

            # in templates/index.html
            {% import "bootstrap/wtf.html" as wtf %}

            {{ wtf.quick_form(form) }}
            <p></p>

    D) Flask-SQLAlchemy: SQLAlchemy 是一个强大的关系型数据库框架，支持多种数据库后台。
                         Object Relationship Mapping (ORM) 包。
                         SQLAlchemy 提供了高层ORM的功能，也提供了原生SQL的底层功能。

        Flask-SQLAlchemy 简化了 SQLAlchemy 在 Flask 中的应用。
        在 Flask-SQLAlchemy 中，数据库使用URL指定，如：
            MySQL:                  mysql://username:password@hostname/database
            Postgres:               postgresql://username:password@hostname/database
            SQLite (Linux, MacOS):  sqlite:///absolute/path/to/database
            SQLite (Windows):       sqlite:///c:/absolute/path/to/database
        此 URL 必须保存到 Flask 配置对象的 SQLALCHEMY_DATABASE_URI 键中。
        而且， SQLALCHEMY_TRACK_MODIFICATIONS = False

        常用的SQLAlchemy列类型：
            Integer, SmallInteger, BigInteger, Float, Numeric,
            String, Text, Unicode, UnicodeText,
            Boolean, Date, Time, DateTime, Interval （对应Python中的datetime.timedelta），
            Enum （对应Python中的str，一组字符串）,
            PickleType （对应Python中的任何Python对象，自动使用Pickle序列化）,
            LargeBinary （对应Python中的str，二进制blob）。
        常用的SQLAlchemy列选项：
            primary_key, unique, index, nullable, default.
        常用的SQLAlchemy关系选项，用在函数 db.relationship(...) 中：
            backref, primaryjoin, lazy, uselist（一对一时可设为False）, order_by, secondary, secondaryjoin.

        Usage Example 1. 增删改查
            # in hello.py
            ...

            # in Terminal
            export FLASK_APP=hello.py
            flask shell
            >>> from hello import db
                db.drop_all()
                db.create_all()
                from hello import Role, User
                admin_role = Role(name='Admin')
                mod_role = Role(name='Moderator')
                user_role = Role(name='User')
                user_john = User(username='john', role=admin_role)
                user_susan = User(username='susan', role=user_role)
                user_david = User(username='david', role=user_role)
                # db.session.add(admin_role)
                # db.session.delete(admin_role)
                db.session.add_all([admin_role, mod_role, user_role, user_john, user_susan, user_david])
                db.session.commit()  # or db.session.rollback()
                print(admin_role.id)
                print(mod_role.id)
                print(user_role.id)

                Role.query.all()
                User.query.all()

                query 过滤器：
                    filter(), filter_by(), order_by(), group_by(), limit(), offset()

                query 执行方法：
                    all(), first(), first_or_404(), get(), get_or_404(), count(), paginate()

                user_role = Role.query.filter_by(name='User').first()
                User.query.filter_by(role=user_role).all()

                # str(...) 返回SQLAlchemy为查询生成的SQL查询语句。
                print(str(User.query.filter_by(role=user_role))

                关系与查询的处理方式类似，同时，
                    执行user_role.users，隐式的查询会调用all()方法，返回一个用户列表。
                    修改关系的设置加入 lazy='dynamic'，从而禁止自动执行查询，
                        此时 user_role.users将返回一个尚未执行的查询，因此可以在其上添加过滤器。

                >>> users = user_role.users
                >>> users
                [<User susan>, <User david>]
                >>> users[0].role
                <Role User>

                # lazy='dynamic'以后，关系上可以添加过滤器
                user_role.users[0] # still works
                user_role.users.order_by(User.username).all()
                user_role.users.count()

        MangoEngine 是 Object Document Mapping (ODM) 包。

        SQL数据库：关系型数据库，主键、外键、关系、实体、实体-关系图、表，记录。。。；
                    采用ACID范式；
        NoSQL数据库：如文档数据库、键-值对数据库，集合（==表）、文档（==记录）。。。；
                    减少了表、但是数据重复；
                    放宽了对ACID范式的要求。

        pip install flask-sqlalchemy

    E) Flask-Migrate：数据库迁移。数据库迁移工具能跟踪数据库模式的变换，然后以增量的方式把变化应用到数据库中。
        Flask中两种方法：1. 直接用 Alembic （Alembic：蒸馏器）这个迁移框架；
                         2. 用Flask-Migrate扩展，这个扩展时对Alemic的轻量级包装，并与flask命令做了集成。

        Flask-SQLAlchemy 在只有数据库表不存在时，才会根据模型创建。
            所以如果有数据库模型的更改，即表结构的改动，需要先删除旧表，但会丢失数据，
            所以最好用Flask-Migrate来更新表。

        用 Flask-Migrate 管理数据库模型变化的步骤如下：
        （1）对模型做必要的修改；
        （2）执行 flask db migrate 命令，自动创建一个迁移脚本；
        （3）检查自动生成的脚本，根据对模型的实际改动进行调整；
        （4）把迁移脚本纳入版本控制；
        （5）执行 flask db upgrade 命令，把迁移应用到数据库中。
        如果前一个迁移还没提交，运行 flask db downgrade， 再重复上述步骤。

        pip install flask-migrate

        flask db init
        flask db migrate
        flask db upgrade
        flask db downgrade
        flask db stamp

    F) Flask-Mail: Python有标准库smtplib可发送邮件，Flask-Mail 包装了 smtplib 能更好的与Flask集成。
        Flask-Mail 连接到 Simple Mail TRanfer Protocol (SMTP)服务器，把邮件交给这个服务器发送。
        Flask-Mail SMTP 服务器的配置和默认值：
            MAIL_SERVER: localhost,
            MAIL_PORT:   25,
            MAIL_USE_TLS: False
            MAIL_USE_SSL: False
            MAIL_USERNAME: None
            MAIL_PASSWORD: None
        上述配置可以在code中设置： app.config[...]  = ... 。

        MAIL_USERNAME, MAIL_PASSWORD 最好放在环境变量里。
        NA_BLOG_ADMIN （email of amdin) 也放在环境变量里。
        # export MAIL_USERNAME =...
        set MAIL_USERNAME =...

        pip install flask_mail

        Usage Example:
            # in flask shell:
            from flask_mail import Message
            from hello import mail
            msg = Message('test email', sender='from_na_blog@gmail.com', recipients=['liuna_liuna@qq.com'])
            msg.body = 'This is the plain text body.'
            msg.html = 'This is the <b>HTML</b> body.'
            with app.app_context():
                mail.send(msg)

    G) Flask-Login：管理已登陆用户的session
            Flask-Login 是一个非常有用的小型扩展，专门用于管理用户身份验证系统中的验证状态，且不依赖于特定的身份验证机制。
            Flask-Login 运转需要应用中有 User 对象，且User模型必须实现以下属性和方法：
                is_authenticated, is_active, is_anonymous, get_id()
            使用 Flask-Login 两种方法：1. 在User模型中实现以上属性和方法；
                                      2. 用Flask-Login 提供的UserMixin类。UserMixin 包含默认实现，能满足多数需求。
            Flask-Login 中定义了 current_user，在 view functions and templates 中自动可用。
                          可以用 current_user.is_authenticated 判断当前用户是否登录。

            Flask-Login 中用户登录过程：
            （1）用户点击 Log In 链接，访问 http://localhost:5000/auth/login， 处理这个URL的函数返回登录表单模板；

            （2）用户输入用户名和密码，点击提交按钮。再次调用同一处理函数，不过这一次处理的是POST请求，不是GET请求。
                a.处理函数验证通过表单提交的凭据，然后调用Flask-Login的 login_user() 函数，登入用户；
                b.login_user() 函数把用户的ID以字符串的形式写入用户会话；
                c.处理数重定向到首页；

            （3）浏览器收到重定向响应，请求首页。
                a.调用首页的视图函数，渲染主页的 Jinja2 模板；
                b.在渲染这个Jinja2 模板的过程中，首次引用Flask-Login的 current_user；
                c.该请求还没有给上下文变量 current_user 赋值，因此调用Flask-Login内部的_get_user()函数，找出用户是谁；
                d._get_user()函数检查用户会话中有没有用户ID，如果没有，返回一个Flask-Login的 AnonymousUser 实例，
                    如果有ID，调用应用中使用 user_loader 装饰器注册的函数，传入用户ID；
                e.应用中的 user_loader 处理函数从数据库中读取用户，将其返回。
                    Flask-Login 把返回到用户对象赋值给当前请求的 current_user 上下文变量。
                f.模板收到新赋值的 current_user。

            pip install flask_login

            Usage Example:
                define class LoginForm in auth/forms.py;
                define login template in templates/auth/login.html;
                update User model in models.py to add email column;
                change index() in auth/views.py, add login(), logout();
                add login_manager in app/__init__.py;
                update template/base.html add Log In/Log Out navigation button;
                update template/index.html to use current_user.is_authenticated;
                migrate db via
                    flask db migrate
                    flask db upgrade
                test in flask shell:
                    u = User(email='john@example.com', username='john', password='cat')
                    db.session.add(u)
                    db.session.commit()
                    # then try http://127.0.0.1:5000/auth/login in browser.



    F) Werkzeug：计算密码的散列值并进行核对
            存储在数据库中的用户密码不能是用户的原始密码，而是hash of password。
                original password + salt -> through multiple uni-directional password convertion -> hash of the password.

            可以用 werkzeug.security generate_password_hash 来生成密码散列，用 check_password_hash 来核对。
                也可以用 bcrypt 和 Passlib 计算密码的散列值。

            Usage Example:
                # in models.py:
                    from werkzeug import generate_password_hash, check_password_hash

                    Class User(db.Model):
                        ...
                        password_hash = db.Column(db.String(128))

                        @property
                        def password(self):
                            raise AttributeError('Password is not a readable attribute')

                        @password.setter
                        def password(self, password):
                            self.password_hash = generate_password_hash(password)

                        def verify_password(self, password):
                            return check_password_hash(self.password_hash, password)

                # check in flask shell:
                    >>> u = User()
                    >>> u.password = 'cat'
                    >>> u.password
                    Traceback (most recent call last):
                      File "<console>", line 1, in <module>
                      File "D:\workspace\pweb\app\models.py", line 47, in password
                        raise AttributeError('Password is not a readable attribute')
                    AttributeError: Password is not a readable attribute
                    >>> u.password_hash
                    'pbkdf2:sha256:150000$ju9iskX6$c693dd143510740e6bb7fcda074f41bb98cb17437608d8177646716304af0c32'
                    >>> u.verify_password('cat')
                    True
                    >>> u.verify_password('dog')
                    False
                    >>> u2 = User()
                    >>> u2.password = 'cat'
                    >>> u2.password_hash
                    'pbkdf2:sha256:150000$Ft6latWs$867a26e074f5e65088d57a32e07990191eac4405586c4e699a2d81e6a7188691'
                    >>> u.password_hash == u2.password_hash
                    False



    H) itsdangerous：生成并核对 加密安全令牌



3.13) Flask开发的大型应用的结构
以一个blog system为例，
    配置放在 config.py中；
    程序入口在 <appname>.py 中如 nablog.py;
    应用相关的放在 app/ 下: __init__.py, code， templates/, static/, email.py, models.py;
                            code 在 main/ 下：main/__init__.py,
                                              main/errors.py,
                                              main/forms.py,
                                              main/views.py,
    路由提取到 blueprint 实现，在 main/__init__.py, main/errors.py, main/views.py里。
    数据库迁移放在 migrations/ 下；
    单元测试放在 tests/ 下；
    依赖包放在 requirements.txt 中；

    app 改为由工厂函数创建：
        def create_app(config_name):
            app = Flask(__name__)
            app.config.from_object(config[config_name])
            config[config_name].init_app(app)
    app 改为由工厂函数创建以后，可以用蓝图在全局作用域中定义路由。

    Notes:
    3.13.1) in sub-class of unittest.TestCase:
            either remove __init__ or in exact __init__(self, *args, **kwargs) format.

    3.13.2) 在 PyCharm 的 Terminal下运行的时候，
            set FLASK_APP=nablog.py
            set FLASK_CONFIG=testing
            flask test

            # or
            set FLASK_APP=nablog.py
            set FLASK_CONFIG=
            flask run

            # or
            set FLASK_APP=nablog.py
            flask shell





#
# Flask 启动、和其他工具的集成
#
1. 1）Nginx、Gunicorn 和 Flask 的关系
Nginx：  处理静态文件，可以缓存一些动态内容，反向代理，负载均衡，对恶意访问加黑名单等等；

Gunicorn：Python实现的网关，实现了 Web Server Gateway Interface (WSGI),
          擅长于管理多进程，有进程挂了Gunicorn可以再拉起来、防止服务器长时间停止服务，
          还可以动态调整worker数量，请求多的时候增加worker的数量、请求少的时候减少，
          这就是所谓的pre-fork模型。

Flask：  内置了一个webserver，给开发者用的；
        不适合生产环境用、单进程(用不了多核）、难扩展（失败了就挂掉）。

生产环境中常用的部署：
    多Nginx + 多Gunicorn + Flask App，Gunicorn用supervisor管理。


# ref: https://www.zhihu.com/question/297267614 https://www.zhihu.com/question/297267614
# ref: 使用了Gunicorn或者uWSGI,为什么还需要Nginx？https://www.zhihu.com/question/30560394

2）gunicorn 配置 nginx
    譬如in /etc/nginx/sites-enabled/wepub:
        server {
            listen 80;
            root /www/demo;
            server_name example.org;

            location / {
                proxy_pass http://127.0.0.1:8000;   # 转发gunicorn的运行地址
            }
        }

    另外可以扩展反向代理部分：
        location / {
            proxy_pass  http://localhost:8000/; # 转发gunicorn的运行地址
            proxy_redirect off;

            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
     静态文件：
        location ~ ^\/static\/.*$ {
            root /www/demo；
        }

# ref: uWSGI和Gunicorn对比实践笔记 https://zhuanlan.zhihu.com/p/50857407

3）用supervisor运行一个program
    # install
    sudo apt-get install supervisor

    # 创建配置文件 /etc/supervisor/conf.d/demo.conf
    [program:demo]
    command=/www/demo/venv/bin/gunicorn -c /pushy/blog/gconfig.py run:app
    directory=/www/demo     # 项目目录
    user=root
    autorestart=true
    startretries=3

    # 保存配置文件以后，需要更新配置文件
    supervisorctl update

    # 启动demo进程
    supervisorctl start demo








# ref: supervisor的安装与简单介绍 https://www.cnblogs.com/Dicky-Zhang/p/6171954.html
# ref: supervisor详解 https://www.cnblogs.com/shijingjing07/p/9395110.html




#
# 2。Gunicorn 知识点
#
WSGI HTTP 服务器，pre-fork worker模式：擅长于管理多进程，所以提升了服务器处理负载的能力。

# install
apt-get install gunicorn
# or
pip install gunicorn

# start
gunicorn -w 2 -b 0.0.0.0:8000 test:application
# or
gunicorn -c gunicorn.conf.py test:application

# simple wsgi interface example in test.py
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html'])
    return b'<h1>Hello, web!</h1>'

    -w worker 数量，推荐 num_of_cpu_cores * 2 + 1,
    -b bind，与指定的socket进行绑定，
    -k WorkerClass, 工作进程类型，包括 sync(default), gevent, eventlet, tornado, gtheread, gaiohttp.
    -c Config，配置文件，一个.py文件，可以实现复杂的逻辑。

# example of gunicorn.conf.py
    from gevent import monkey
    monkey.patch_all()
    import multiprocessing
    debug = True
    loglevel = 'debug'
    bind = '127.0.0.1:5000'     # 绑定与 Nginx 通信的端口
    pidfile = 'log/gunicorn.pid'
    logfile = 'log/debug.log'
    workers = multiprocessing.cpu_count() * 2 + 1
    worker_class = 'gevent'     # 默认是sync，阻塞模式，最好选择gevent模式






# ref: Gunicorn使用详解 https://www.cnblogs.com/shijingjing07/p/9110619.html
# ref: nginx+uwsgi 和nginx+gunicorn区别、如何部署 https://www.jianshu.com/p/be2b587a900e
# ref: 深入理解uwsgi和gunicorn网络模型 https://blog.csdn.net/shudaqi2010/article/details/71172683

#
# 3. Flask 原理、语法
#


# ref: Flask源码解析:Flask应用执行流程及原理 https://www.cnblogs.com/weihengblog/p/9490561.html


